<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客编辑常用工具</title>
    <url>//0/</url>
    <content><![CDATA[<ol>
<li>奥森图标（<a href="https://www.thinkcmf.com/font_awesome.html">Font Awesome</a>）提供丰富的矢量字体图标—通过CSS可以任意控制所有图标的大小 ，颜色，阴影。</li>
<li><a href="http://www.swig.org/exec.html">SWIG</a>是一个接口编译器，用于将用C和C ++编写的程序与脚本语言（例如Perl，Python，Ruby和Tcl）连接起来。它通过获取C / C ++头文件中的声明并使用它们来生成脚本语言访问基础C / C ++代码所需的包装器代码来工作。此外，SWIG提供了各种自定义功能，可让您定制包装过程以适合您的应用程序。</li>
<li><a href="https://tableconvert.com/">tableconvert</a>是一个在线表格转换的工具，可以把填写的表格生成markdown，sql等语句。<span id="more"></span></li>
<li><a href="https://hexo.io/zh-cn/docs/commands.html">hexo</a>常用指令:<br>（1）新建一篇博客</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>（2）生成静态文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">//</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>（3）本地运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">//</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>（4）在github上运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">//</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>例：<a href="https://xdw-h.github.io/">author blog</a></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>call、apply、bind、new的手写</title>
    <url>//1/</url>
    <content><![CDATA[<h3 id="一、实现call函数"><a href="#一、实现call函数" class="headerlink" title="一、实现call函数"></a>一、实现call函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.c = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当传入的t为基础类型时，直接挂载fn会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> t !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="built_in">Object</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//t为可选参数，如果不传的话默认上下文为window</span></span><br><span class="line">    t = t || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">//给t创建一个fn属性，并将值设置为需要调用的函数 </span></span><br><span class="line">    t.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//call可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> result = t.fn(...args)</span><br><span class="line">    <span class="comment">//调用函数并将对象上的函数删除</span></span><br><span class="line">    <span class="keyword">delete</span> t.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="二、实现apply函数"><a href="#二、实现apply函数" class="headerlink" title="二、实现apply函数"></a>二、实现apply函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当传入的t为基础类型时，直接挂载fn会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> t !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="built_in">Object</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//t为可选参数，如果不传的话默认上下文为window</span></span><br><span class="line">    t = t || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">//给t创建一个fn属性，并将值设置为需要调用的函数 </span></span><br><span class="line">    t.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> r</span><br><span class="line">    <span class="comment">//处理参数和call有区别</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">        r = t.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = t.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> t.fn</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、实现bind函数"><a href="#三、实现bind函数" class="headerlink" title="三、实现bind函数"></a>三、实现bind函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.protype.b = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> args = [...argument].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="comment">//对于new的情况，不会被任何方式改变this，所以对于这种情况我们需要忽略传入的this</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(..args, ...arguments)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//直接调用，使用apply，因为bind可以实现柯里化，f.find(obj,1)(2)，所以需要将两边的参数拼接起来</span></span><br><span class="line">            <span class="keyword">return</span> _this.apply(t, args.concat(...arguments))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、实现一个new"><a href="#四、实现一个new" class="headerlink" title="四、实现一个new"></a>四、实现一个new</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//新生成一个对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">//获取构造函数</span></span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">//链接到原型</span></span><br><span class="line">    obj.__proto__ = Con.prototype</span><br><span class="line">    <span class="comment">//绑定this并执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">//确保返回值为对象</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>//10/</url>
    <content><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h5><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个; </li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数; </li>
<li>针对所有的元素重复以上的步骤，除了最后一个; </li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<span id="more"></span>

<h5 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h5><p><img src="/10/bubbleSort.gif" alt="bubbleSort"></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[i]) &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法步骤：-1"><a href="#算法步骤：-1" class="headerlink" title="算法步骤："></a>算法步骤：</h5><ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ol>
<h5 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h5><p><img src="/10/selectionSort.gif" alt="selectionSort"></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[minIndex];</span><br><span class="line">        arr[minIndex] = a[i];</span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ol>
<h5 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h5><p><img src="/10/insertionSort.gif" alt="insertionSort"></p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> preIndex, cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        cur = arr[i]</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; cur) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<h5 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h5><p><img src="/10/shellSort.gif" alt="shellSort"></p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> gap = <span class="number">1</span>,</span><br><span class="line">        temp;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">let</span> j = i - gap;</span><br><span class="line">            <span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h5 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h5><p><img src="/10/mergeSort.gif" alt="mergeSort"></p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123; <span class="comment">// 采用自上而下的递归方法</span></span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3 与 vite</title>
    <url>//11/</url>
    <content><![CDATA[<h3 id="vue3-与-vite"><a href="#vue3-与-vite" class="headerlink" title="vue3 与 vite"></a>vue3 与 vite</h3><h4 id="vue-2-x-与-vue-3-x"><a href="#vue-2-x-与-vue-3-x" class="headerlink" title="vue 2.x 与 vue 3.x"></a>vue 2.x 与 vue 3.x</h4><p>2.x 时代的 Vue 没有“应用”的概念，所谓的应用只是一个 Vue 的根实例  new Vue() 。<br>当我们需要修改一些全局属性的时候，只能通过 Vue 对象本身来修改，比如：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.x 时代的全局属性</span></span><br><span class="line">Vue.prototype.$http = axios;</span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">    inserted: <span class="function"><span class="params">el</span> =&gt;</span> el.focus()</span><br><span class="line">&#125;);</span><br><span class="line">Vue.config.errorHandler = errorHandler;</span><br></pre></td></tr></table></figure>
<p>这样的行为会污染 Vue 对象，导致从同一个 Vue 创建的实例会共享相同的全局配置<br>而通过 createApp 返回的是独立的实例，修改该实例的属性不会影响其他 createApp 创建的实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.x createApp</span></span><br><span class="line"><span class="keyword">const</span> foo = createApp(Foo);</span><br><span class="line">foo.directive(<span class="string">&#x27;focus&#x27;</span> <span class="comment">/* ... */</span>);</span><br><span class="line"><span class="keyword">const</span> bar = createApp(Bar);</span><br><span class="line">bar.directive(<span class="string">&#x27;focus&#x27;</span> <span class="comment">/* ... */</span>);</span><br><span class="line"><span class="comment">// foo 和 bar 都具备了 focus 指令，但这两个指令的内容相互独立</span></span><br></pre></td></tr></table></figure>
<p>如果确实需要两个应用共享配置，还可以通过 createApp 创建一个工厂函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createMyApp = <span class="function"><span class="params">options</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> app = createApp(options)</span><br><span class="line">  app.directive(<span class="string">&#x27;focus&#x27;</span> <span class="comment">/* ... */</span>)</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = createMyApp(Foo).mount(<span class="string">&#x27;#foo&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bar = createMyApp(Bar).mount(<span class="string">&#x27;#bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 和 bar 会具备同一个 focus 指令</span></span><br></pre></td></tr></table></figure>
<h4 id="使用-Vite-构建项目"><a href="#使用-Vite-构建项目" class="headerlink" title="使用 Vite 构建项目"></a>使用 Vite 构建项目</h4><p>除了上面的 Vue CLI 创建项目之外，Vue 3.x 还可以通过新工具 Vite 创建项目。<br>Vite 是一个由原生 ES 模块驱动的 Web 开发构建工具，支持模块热更新和按需加载。</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="Vue-directive-的用法和实例"><a href="#Vue-directive-的用法和实例" class="headerlink" title="Vue.directive()的用法和实例"></a>Vue.directive()的用法和实例</h5><p>指令定义函数提供了几个钩子函数（可选）：</p>
<ol>
<li>bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</li>
<li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。</li>
<li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li>
<li>unbind: 只调用一次， 指令与元素解绑时调用。</li>
</ol>
<ul>
<li>官网demo,刷新页面input自动获取焦点<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-focus</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册一个全局自定义指令 v-focus</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">//当绑定元素插入到DOM中。</span></span><br><span class="line">    inserted: <span class="function"><span class="title">fuction</span>(<span class="params">el, binding</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//聚焦元素</span></span><br><span class="line">        el.focus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>一个拖拽的demo</li>
</ul>
<ol>
<li>被拖拽的元素必须用position定位，才能被拖动；</li>
<li>自定义指令完成后需要实例化Vue,挂载元素；</li>
<li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">	.one,.two&#123;</span><br><span class="line"><span class="css">		<span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">border</span>:<span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">		<span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">		-webkit-user-select: none;</span></span><br><span class="line"><span class="css">		-ms-user-select: none;</span></span><br><span class="line"><span class="css">		-moz-user-select: -moz-none;</span></span><br><span class="line"><span class="css">		<span class="attribute">cursor</span>: pointer;</span></span><br><span class="line">	&#125;</span><br><span class="line">	.two&#123;</span><br><span class="line"><span class="css">		<span class="attribute">left</span>:<span class="number">200px</span>;</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span> <span class="attr">v-drag</span>&gt;</span>拖拽one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span> <span class="attr">v-drag</span>&gt;</span>拖拽two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;drag&#x27;</span>, &#123;</span><br><span class="line">	inserted:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">	    el.οnmοusedοwn=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	        <span class="keyword">let</span> l=e.clientX-el.offsetLeft;</span><br><span class="line">	        <span class="keyword">let</span> t=e.clientY-el.offsetTop;</span><br><span class="line">	        <span class="built_in">document</span>.οnmοusemοve=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">	            el.style.left=e.clientX-l+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">	            el.style.top=e.clientY-t+<span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">	        &#125;;</span><br><span class="line">	        el.οnmοuseup=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	            <span class="built_in">document</span>.οnmοusemοve=<span class="literal">null</span>;</span><br><span class="line">	            el.οnmοuseup=<span class="literal">null</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">　　el:<span class="string">&#x27;#app&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>转发：<a href="https://www.cnblogs.com/wisewrong/p/13717287.html">https://www.cnblogs.com/wisewrong/p/13717287.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>yarn 与 npm</title>
    <url>//12/</url>
    <content><![CDATA[<h3 id="yarn-与-npm"><a href="#yarn-与-npm" class="headerlink" title="yarn 与 npm"></a>yarn 与 npm</h3><h4 id="yarn优点"><a href="#yarn优点" class="headerlink" title="yarn优点"></a>yarn优点</h4><ul>
<li>速度快</li>
</ul>
<ol>
<li>并行安装，npm是按照队列执行每个package，需要排队。而yarn是同步执行所有任务，提高了性能。</li>
<li>离线模式：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。</li>
</ol>
<span id="more"></span>

<ul>
<li><p>安装版本统一：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 npm shrinkwrap 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。</p>
</li>
<li><p>更简洁的输出：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。</p>
</li>
<li><p>多注册来源处理：所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。</p>
</li>
<li><p>更好的语义化： yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。</p>
</li>
</ul>
<h4 id="Yarn和npm命令对比"><a href="#Yarn和npm命令对比" class="headerlink" title="Yarn和npm命令对比"></a>Yarn和npm命令对比</h4><table>
<thead>
<tr>
<th>npm</th>
<th>yarn</th>
</tr>
</thead>
<tbody><tr>
<td>npm install</td>
<td>yarn</td>
</tr>
<tr>
<td>npm install react –save</td>
<td>yarn add react</td>
</tr>
<tr>
<td>npm uninstall react –save</td>
<td>yarn remove react</td>
</tr>
<tr>
<td>npm install react –save-dev</td>
<td>yarn add react –dev</td>
</tr>
<tr>
<td>npm update –save</td>
<td>yarn upgrade</td>
</tr>
</tbody></table>
<h4 id="npm5-0"><a href="#npm5-0" class="headerlink" title="npm5.0"></a>npm5.0</h4><p>有了yarn的压力之后，npm做了一些类似的改进。</p>
<ol>
<li>默认新增了类似yarn.lock的 package-lock.json；</li>
<li>git 依赖支持优化：这个特性在需要安装大量内部项目（例如在没有自建源的内网开发），或需要使用某些依赖的未发布版本时很有用。在这之前可能需要使用指定 commit_id 的方式来控制版本。</li>
<li>文件依赖优化：在之前的版本，如果将本地目录作为依赖来安装，将会把文件目录作为副本拷贝到 node_modules 中。而在 npm5 中，将改为使用创建 symlinks 的方式来实现（使用本地 tarball 包除外），而不再执行文件拷贝。这将会提升安装速度。目前yarn还不支持。</li>
</ol>
<p>转发：<a href="https://www.cnblogs.com/ajaemp/p/14437117.html">https://www.cnblogs.com/ajaemp/p/14437117.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>单页应用和多页应用的区别</title>
    <url>//13/</url>
    <content><![CDATA[<h3 id="单页应用和多页应用的区别"><a href="#单页应用和多页应用的区别" class="headerlink" title="单页应用和多页应用的区别"></a>单页应用和多页应用的区别</h3><h4 id="单页面应用（SinglePage-Web-Application，SPA）"><a href="#单页面应用（SinglePage-Web-Application，SPA）" class="headerlink" title="单页面应用（SinglePage Web Application，SPA）"></a>单页面应用（SinglePage Web Application，SPA）</h4><p>只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次，常用于PC端官网、购物等网站。</p>
<p><img src="/13/13-1.png"></p>
<h4 id="多页面应用（MultiPage-Application，MPA）"><a href="#多页面应用（MultiPage-Application，MPA）" class="headerlink" title="多页面应用（MultiPage Application，MPA）"></a>多页面应用（MultiPage Application，MPA）</h4><p>多页面跳转刷新所有资源，每个公共资源(js、css等)需选择性重新加载，常用于 app 或 客户端等。</p>
<span id="more"></span>

<h4 id="具体对比分析"><a href="#具体对比分析" class="headerlink" title="具体对比分析"></a>具体对比分析</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">单页面应用（SinglePage Web Application，SPA）</th>
<th align="center">多页面应用（MultiPage Application，MPA）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">组成</td>
<td align="center">一个外壳页面和多个页面片段组成</td>
<td align="center">多个完整页面构成</td>
</tr>
<tr>
<td align="center">资源共用(css, js)</td>
<td align="center">共用，只需在外壳部分加载</td>
<td align="center">不共用，每个页面都需要加载</td>
</tr>
<tr>
<td align="center">刷新方式</td>
<td align="center">页面局部刷新或更改</td>
<td align="center">整页刷新</td>
</tr>
<tr>
<td align="center">url 模式</td>
<td align="center">a.com/#/pageone a.com/#/pagetwo</td>
<td align="center">a.com/pageone.html a.com/pagetwo.html</td>
</tr>
<tr>
<td align="center">用户体验</td>
<td align="center">页面片段间的切换快，用户体验良好</td>
<td align="center">页面切换加载缓慢，流畅度不够，用户体验比较差</td>
</tr>
<tr>
<td align="center">转场动画</td>
<td align="center">容易实现</td>
<td align="center">无法实现</td>
</tr>
<tr>
<td align="center">数据传递</td>
<td align="center">容易</td>
<td align="center">依赖 url传参、或者cookie 、localStorage等</td>
</tr>
<tr>
<td align="center">搜索引擎优化(SEO)</td>
<td align="center">需要单独方案、实现较为困难、不利于SEO检索 可利用服务器端渲染(SSR)优化</td>
<td align="center">实现方法简易</td>
</tr>
<tr>
<td align="center">试用范围</td>
<td align="center">高要求的体验度、追求界面流畅的应用</td>
<td align="center">适用于追求高度支持搜索引擎的应用</td>
</tr>
<tr>
<td align="center">开发成本</td>
<td align="center">较高，常需借助专业的框架</td>
<td align="center">较低 ，但页面重复代码多</td>
</tr>
<tr>
<td align="center">维护成本</td>
<td align="center">相对容易</td>
<td align="center">相对复杂</td>
</tr>
</tbody></table>
<p>单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。</p>
<p>多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新</p>
<h4 id="单页面的优点："><a href="#单页面的优点：" class="headerlink" title="单页面的优点："></a>单页面的优点：</h4><p>1、用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小</p>
<p>2、前后端分离</p>
<p>3、页面效果会比较炫酷（比如切换页面内容时的专场动画）</p>
<h4 id="单页面缺点："><a href="#单页面缺点：" class="headerlink" title="单页面缺点："></a>单页面缺点：</h4><p>1，不利于seo</p>
<p>2，导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）</p>
<p>3，初次加载时耗时多</p>
<p>4，页面复杂度提高很多</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6：WeakSet，Set，Map，WeakMap</title>
    <url>//14/</url>
    <content><![CDATA[<h3 id="ES6：WeakSet，Set，Map，WeakMap"><a href="#ES6：WeakSet，Set，Map，WeakMap" class="headerlink" title="ES6：WeakSet，Set，Map，WeakMap"></a>ES6：WeakSet，Set，Map，WeakMap</h3><p>Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ol>
<li>Set是一个集合，里面的值都是唯一的，没有重复的。</li>
<li>Set中可以是任何数据类型，并且添加数据时会进行严格比较，重复数据无法加入。</li>
<li>Set 本身是一个构造函数，用来生成 Set 数据结构。</li>
<li>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</li>
<li>Set 对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li>
</ol>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function">(<span class="params">x</span>) =&gt;</span> s.add(x))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure>

<h5 id="Set-中的特殊值"><a href="#Set-中的特殊值" class="headerlink" title="Set 中的特殊值"></a>Set 中的特殊值</h5><p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p>
<ol>
<li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；</li>
<li>undefined 与 undefined 是恒等的，所以不重复；</li>
<li>NaN 与 NaN 是不恒等的，但是在 Set 中认为 NaN 与 NaN 相等，所有只能存在一个，不重复。</li>
</ol>
<h5 id="Set-的属性"><a href="#Set-的属性" class="headerlink" title="Set 的属性"></a>Set 的属性</h5><p>size：返回集合所包含元素的数量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">items.size <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h5 id="Set-实例对象的方法"><a href="#Set-实例对象的方法" class="headerlink" title="Set 实例对象的方法"></a>Set 实例对象的方法</h5><ol>
<li>add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。</li>
<li>delete(value)：删除某个值，删除成功返回 true，否则返回 false。</li>
<li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line">s.delete(<span class="number">2</span>)</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h5><ol>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回键值对的遍历器。</li>
<li>forEach()：使用回调函数遍历每个成员。</li>
</ol>
<p>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure>

<h5 id="Array-和-Set-对比"><a href="#Array-和-Set-对比" class="headerlink" title="Array 和 Set 对比"></a>Array 和 Set 对比</h5><ol>
<li>Array 的 indexOf 方法比 Set 的 has 方法效率低下</li>
<li>Set 不含有重复值（可以利用这个特性实现对一个数组的去重）</li>
<li>Set 通过 delete 方法删除某个值，而 Array 只能通过 splice。两者的使用方便程度前者更优</li>
<li>Array 的很多新方法 map、filter、some、every 等是 Set 没有的（但是通过两者可以互相转换来使用）</li>
</ol>
<h5 id="Set-的应用"><a href="#Set-的应用" class="headerlink" title="Set 的应用"></a>Set 的应用</h5><p>1、Array.from 方法可以将 Set 结构转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items)</span><br></pre></td></tr></table></figure>

<p>2、数组去重</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array))</span><br></pre></td></tr></table></figure>

<p>3、数组的map和filter方法也可以间接用于set</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>))</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> x % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>4、实现并集 (Union)、交集 (Intersect) 和差集</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b])</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> b.has(x)))</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.has(x)))</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([...b].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !a.has(x)))</span><br><span class="line"><span class="comment">// Set &#123;4&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><ol>
<li>弱引用Set。只能存储对象，不能存储其他类型。且只保持对其中对象的弱引用，若外部无对此对象的引用，或者对象被删除，则WeakSet中将不再有此对象。</li>
<li>因为成员都是弱引用，随时可能消失，遍历不能保证成员的存在。所以 WeakSet 不能遍历。</li>
<li>WeakSet 结构与 Set 类似，也是不重复的值的集合。</li>
<li>成员都是数组和类似数组的对象，若调用 add() 方法时传入了非数组和类似数组的对象的参数，就会抛出错误。</li>
<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏。</li>
<li>WeakSet 不可迭代，因此不能被用在 for-of 等循环中。</li>
<li>WeakSet 没有 size 属性。</li>
</ol>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map是一个键值对。</p>
<p>Map与Object的区别是：</p>
<ol>
<li>Object的key只能是String和Symbol类型，而Map的key可以是任何基本类型(String, Number, Boolean, undefined, NaN….)或对象类型(Map, Set, Object, Function , Symbol , null….)</li>
<li>Map有size属性，可以方便的获取Map的长度，但是Object无法直接获取长度</li>
</ol>
<p>Map 的属性:</p>
<ol>
<li>size: 返回集合所包含元素的数量</li>
</ol>
<p>Map 对象的方法:</p>
<ol>
<li>set(key, val): 向 Map 中添加新元素</li>
<li>get(key): 通过键值查找特定的数值并返回</li>
<li>has(key): 判断 Map 对象中是否有 Key 所对应的值，有返回 true，否则返回 false</li>
<li>delete(key): 通过键值从 Map 中移除对应的数据</li>
<li>clear(): 将这个 Map 中的所有元素删除</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">    p: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">m.set(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.get(o) <span class="comment">// &quot;content&quot;</span></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>弱引用Map。WeakMap有如下特点：</p>
<ol>
<li>WeakMap的key只能是对象，不能是基本类型，且对象不计入垃圾回收机制</li>
<li>WeakMap没有keys、values、entries、size方法</li>
<li>WeakMap没有遍历操作，无法遍历</li>
</ol>
<p>WeakMap和WeakSet的作用，可以用来存储DOM节点，保持与DOM节点相关的数据，当DOM节点被删除后，集合中的数据自动删除，<br>这样就不必担心移除DOM节点时的内存泄漏了。</p>
<p>转发：<a href="https://segmentfault.com/a/1190000022936727">https://segmentfault.com/a/1190000022936727</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>衍生：ESLint的运行原理</title>
    <url>//15/</url>
    <content><![CDATA[<h3 id="衍生：ESLint的运行原理"><a href="#衍生：ESLint的运行原理" class="headerlink" title="衍生：ESLint的运行原理"></a>衍生：ESLint的运行原理</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ESLint 的用法包括两部分： 通过配置文件配置 lint 规则； 通过命令行执行 lint，找出不符合规范的地方；</p>
<h4 id="配置-ESLint"><a href="#配置-ESLint" class="headerlink" title="配置 ESLint"></a>配置 ESLint</h4><p>通过 eslint –init 随后做各种选择是生成 eslint 配置文件的一种常见方式。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack构建原理分析</title>
    <url>//16/</url>
    <content><![CDATA[<h3 id="webpack构建原理分析"><a href="#webpack构建原理分析" class="headerlink" title="webpack构建原理分析"></a>webpack构建原理分析</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol>
<li>entry：一个可执行模块或者库的入口。</li>
<li>chunk：多个文件组成一个代码块。可以将可执行的模块和他所依赖的模块组合成一个chunk，这是打包。</li>
<li>loader：文件转换器。例如把es6转为es5，scss转为css等</li>
<li>plugin：扩展webpack功能的插件。在webpack构建的生命周期节点上加入扩展hook，添加功能。</li>
</ol>
<span id="more"></span>

<h4 id="webpack构建流程（原理）"><a href="#webpack构建流程（原理）" class="headerlink" title="webpack构建流程（原理）"></a>webpack构建流程（原理）</h4><p>从启动构建到输出结果一系列过程：</p>
<p>1.初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。</p>
<p>2.开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。</p>
<p>3.确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。</p>
<p>（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</p>
<p>（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。</p>
<p>（6）输出完成：输出所有的chunk到文件系统。</p>
<p>注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。</p>
<p>转发：<a href="https://www.cnblogs.com/chengxs/p/11022842.html">https://www.cnblogs.com/chengxs/p/11022842.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>ES6</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack如何提高构建速度</title>
    <url>//17/</url>
    <content><![CDATA[<h3 id="webpack如何提高构建速度"><a href="#webpack如何提高构建速度" class="headerlink" title="webpack如何提高构建速度"></a>webpack如何提高构建速度</h3><ol>
<li>多入口情况下，使用CommonsChunkPlugin来提取公共代码；</li>
<li>通过externals配置来提取常用库;</li>
<li>利用DllPlugin和DllReferencePlugin预编译资源模块通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来;</li>
<li>使用Happypack 实现多线程加速编译;</li>
<li>使用webpack-uglify-paralle来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度;</li>
<li>使用Tree-shaking和Scope Hoisting来剔除多余代码.</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>ES6</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree-shaking</title>
    <url>//18/</url>
    <content><![CDATA[<h3 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree-shaking"></a>Tree-shaking</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>git和svn</title>
    <url>//19/</url>
    <content><![CDATA[<h3 id="git和svn"><a href="#git和svn" class="headerlink" title="git和svn"></a>git和svn</h3><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol>
<li>SVN（Subversion）是集中式管理的版本控制器，而Git是分布式管理的版本控制器！这是两者之间最核心的区别。</li>
<li>SVN只有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</li>
<li>Git每一个终端都是一个仓库，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。每一次的提取操作，实际上都是一次对代码仓库的完整备份。</li>
<li>Git不仅仅是个版本控制系统，它也是个内容管理系统（CMS），工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应Git提供的一些概念和特征。</li>
</ol>
<span id="more"></span>

<p><img src="/19/git.png" alt="git"></p>
<p><img src="/19/svn.png" alt="svn"></p>
<h4 id="集中式版本控制系统："><a href="#集中式版本控制系统：" class="headerlink" title="集中式版本控制系统："></a>集中式版本控制系统：</h4><p>版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p><img src="/19/tsg.png" alt="tsg"></p>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟。</p>
<h4 id="分布式版本控制系统："><a href="#分布式版本控制系统：" class="headerlink" title="分布式版本控制系统："></a>分布式版本控制系统：</h4><ol>
<li>首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</li>
<li>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</li>
<li>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</li>
</ol>
<p>当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。</p>
<p>转发：<a href="https://www.cnblogs.com/kevingrace/p/5904595.html">https://www.cnblogs.com/kevingrace/p/5904595.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>代码管理</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>//2/</url>
    <content><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><blockquote>
<p>接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
</blockquote>
<span id="more"></span>

<h3 id="二、add函数示例"><a href="#二、add函数示例" class="headerlink" title="二、add函数示例"></a>二、add函数示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通的add函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    rerturn x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//柯里化后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">//3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h3 id="三、优点"><a href="#三、优点" class="headerlink" title="三、优点"></a>三、优点</h3><h4 id="1-参数复用"><a href="#1-参数复用" class="headerlink" title="1. 参数复用"></a>1. 参数复用</h4><p>例：封装正则校验</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//柯里化后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        retunr reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字校验</span></span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">hasNumber(<span class="string">&#x27;test1&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="2-提前确认"><a href="#2-提前确认" class="headerlink" title="2. 提前确认"></a>2. 提前确认</h4><p>例：封装dom操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原函数</span></span><br><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">isSupport</span>)</span></span><br></pre></td></tr></table></figure>
<p>转发： <a href="https://www.jianshu.com/p/2975c25e4d71">https://www.jianshu.com/p/2975c25e4d71</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-dev-server解决跨域</title>
    <url>//20/</url>
    <content><![CDATA[<h3 id="webpack-dev-server解决跨域"><a href="#webpack-dev-server解决跨域" class="headerlink" title="webpack-dev-server解决跨域"></a>webpack-dev-server解决跨域</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>Webpack</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中mixins的使用方法和注意点</title>
    <url>//21/</url>
    <content><![CDATA[<h3 id="vue中mixins的使用方法和注意点"><a href="#vue中mixins的使用方法和注意点" class="headerlink" title="vue中mixins的使用方法和注意点"></a>vue中mixins的使用方法和注意点</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>混入 (mixins)： 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。</p>
<span id="more"></span>

<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个混入对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            num: <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;hello from mixin&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把混入对象混入到当前的组件中</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    组件</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;myMixin&#125; from &#39;@&#x2F;assets&#x2F;mixin.js&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    mixins:[myMixin],</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>方法和参数在各组件中不共享</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    组件1</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;myMixin&#125; from &#39;@&#x2F;assets&#x2F;mixin.js&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    mixins:[myMixin],</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(&quot;组件1：&quot;,this.num++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    组件2</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;myMixin&#125; from &#39;@&#x2F;assets&#x2F;mixin.js&#39;</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    mixins:[myMixin],</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(&quot;组件2：&quot;,this.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>输出：<br>组件1：2<br>组件2：1</p>
<ol start="2">
<li>值为对象的选项，如methods,components等，选项会被合并，键冲突的组件会覆盖混入对象的</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 混入对象中的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            num: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hello();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="function"><span class="title">func_one</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)；</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">func_two</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组件中的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mixins: [myMixin],</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.func_three();</span><br><span class="line">        <span class="built_in">this</span>.func_one();</span><br><span class="line">        <span class="built_in">this</span>.func_two();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods &#123;</span><br><span class="line">        <span class="function"><span class="title">func_three</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">func_two</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<br>3<br>1<br>4</p>
<ol start="3">
<li>值为函数的选项，如created,mounted等，就会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//混入对象函数中的console</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myMixin = &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            num: <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;mixin&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组件函数中的console</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    mixins: [myMixin],</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;self&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：<br>mixin<br>self</p>
<h4 id="与vuex的区别"><a href="#与vuex的区别" class="headerlink" title="与vuex的区别"></a>与vuex的区别</h4><ol>
<li>vuex：用来做状态管理的，里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。</li>
<li>Mixins：可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。</li>
</ol>
<h4 id="与公共组件的区别"><a href="#与公共组件的区别" class="headerlink" title="与公共组件的区别"></a>与公共组件的区别</h4><ol>
<li><p>组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。</p>
</li>
<li><p>Mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。</p>
</li>
</ol>
<p>转发：<a href="https://www.jianshu.com/p/bcff647d24ec">https://www.jianshu.com/p/bcff647d24ec</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue混入</tag>
      </tags>
  </entry>
  <entry>
    <title>git 常用指令</title>
    <url>//22/</url>
    <content><![CDATA[<h3 id="git-常用指令"><a href="#git-常用指令" class="headerlink" title="git 常用指令"></a>git 常用指令</h3><h4 id="git-clone-命令"><a href="#git-clone-命令" class="headerlink" title="git clone 命令"></a>git clone 命令</h4><blockquote>
<p>$ git clone <a href="https://github.com/libgit2/libgit2">https://github.com/libgit2/libgit2</a></p>
</blockquote>
<p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p>
<p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p>
<blockquote>
<p>$ git clone <a href="https://github.com/libgit2/libgit2">https://github.com/libgit2/libgit2</a> mylibgit</p>
</blockquote>
<p>这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。</p>
<span id="more"></span>

<h4 id="git-status-命令"><a href="#git-status-命令" class="headerlink" title="git status 命令"></a>git status 命令</h4><p>可以用 git status 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p>
<blockquote>
<p>$ git status<br>On branch master<br>Your branch is up-to-date with ‘origin/master’.<br>nothing to commit, working directory clean</p>
</blockquote>
<p>当前目录下没有出现任何处于未跟踪状态的新文件，若新增或者修改了文件则会出现以下输出：</p>
<blockquote>
<p>$ echo ‘My Project’ &gt; README<br>$ git status<br>On branch master<br>Your branch is up-to-date with ‘origin/master’.<br>Untracked files:<br>(use “git add <file>…” to include in what will be committed)</file></p>
<p>README</p>
<p>nothing added to commit but untracked files present (use  “git add” to track)</p>
</blockquote>
<p>git status 命令的输出十分详细，但其用语有些繁琐。<br>Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。<br>如果你使用 git status -s 命令或 git status –short 命令，你将得到一种格式更为紧凑的输出。</p>
<blockquote>
<p>$ git status -s<br>M README<br>MM Rakefile<br>A  lib/git.rb<br>M  lib/simplegit.rb<br>?? LICENSE.txt</p>
</blockquote>
<p>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile 文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p>
<h4 id="git-add-命令"><a href="#git-add-命令" class="headerlink" title="git add 命令"></a>git add 命令</h4><blockquote>
<p>$ git add README</p>
</blockquote>
<p>新文件可通过git add来跟踪， git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p>
<h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 来看一个实际的 .gitignore 例子：</p>
<blockquote>
<p>$ cat .gitignore<br>*.[oa]<br>*~</p>
</blockquote>
<p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。</p>
<blockquote>
<p>//忽略所有的 .a 文件<br><em>.a<br>//但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件<br>!lib.a<br>//只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO<br>/TODO<br>//忽略任何目录下名为 build 的文件夹<br>build/<br>//忽略 doc/notes.txt，但不忽略 doc/server/arch.txt<br>doc/</em>.txt<br>//忽略 doc/ 目录及其所有子目录下的 .pdf 文件<br>doc/**/*.pdf</p>
</blockquote>
<h4 id="git-diff-命令"><a href="#git-diff-命令" class="headerlink" title="git diff 命令"></a>git diff 命令</h4><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff：</p>
<blockquote>
<p>$ git diff</p>
</blockquote>
<p> 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。</p>
<p> 若要查看已暂存的将要添加到下次提交里的内容，可以用</p>
<blockquote>
<p>git diff –staged （ –staged 和 –cached 是同义词）</p>
</blockquote>
<p>命令。 这条命令将比对已暂存文件与最后一次提交的文件差异。</p>
<h4 id="git-commit-命令"><a href="#git-commit-命令" class="headerlink" title="git commit 命令"></a>git commit 命令</h4><p>现在的暂存区已经准备就绪，可以提交了。 在此之前，请务必确认还有什么已修改或新建的文件还没有 git add 过， 否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit。在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行。</p>
<blockquote>
<p>git commit -m “提交代码”</p>
</blockquote>
<p>给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。</p>
<blockquote>
<p>$ git commit -a -m ‘提交代码’</p>
</blockquote>
<p>最好还是不要不要跳过git add 步骤，防止提交无用没见，每次提交前都执行下git status 查看文件状态。</p>
<h4 id="git-rm-命令"><a href="#git-rm-命令" class="headerlink" title="git rm 命令"></a>git rm 命令</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<blockquote>
<p>$ git rm PROJECTS.md</p>
</blockquote>
<p>下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 –cached 选项：</p>
<blockquote>
<p>$ git rm –cached README</p>
</blockquote>
<p>git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。比如：</p>
<blockquote>
<p>$ git rm log/*.log</p>
</blockquote>
<p>注意到星号 * 之前的反斜杠 \， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 log/ 目录下扩展名为 .log 的所有文件。 类似的比如：</p>
<blockquote>
<p>$ git rm *~</p>
</blockquote>
<p>该命令会删除所有名字以 ~ 结尾的文件。</p>
<h4 id="git-mv-命令"><a href="#git-mv-命令" class="headerlink" title="git mv 命令"></a>git mv 命令</h4><p> 要在 Git 中对文件改名，可以这么做：</p>
<blockquote>
<p>$ git mv file_from file_to</p>
</blockquote>
<p> 其实，运行 git mv 就相当于运行了下面三条命令：</p>
<blockquote>
<p>$ mv README.md README<br>$ git rm README.md<br>$ git add README</p>
</blockquote>
<h4 id="git-log-命令"><a href="#git-log-命令" class="headerlink" title="git log 命令"></a>git log 命令</h4><blockquote>
<p>git log</p>
</blockquote>
<p>不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<blockquote>
<p>$ git log -p -2</p>
</blockquote>
<p>-p 或 –patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 -2 选项来只显示最近的两次提交。</p>
<p>该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，这个参数就非常有用了。</p>
<blockquote>
<p>$ git log –stat</p>
</blockquote>
<p>如果想看到每次提交的简略统计信息，可以使用 –stat 选项。</p>
<p>参考：<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93">https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>代码管理</tag>
      </tags>
  </entry>
  <entry>
    <title>svn 常用指令</title>
    <url>//23/</url>
    <content><![CDATA[<h3 id="svn-常用指令"><a href="#svn-常用指令" class="headerlink" title="svn 常用指令"></a>svn 常用指令</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>代码管理</tag>
      </tags>
  </entry>
  <entry>
    <title>git的传输协议</title>
    <url>//24/</url>
    <content><![CDATA[<h3 id="git的传输协议"><a href="#git的传输协议" class="headerlink" title="git的传输协议"></a>git的传输协议</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。</p>
<p>值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。</p>
<span id="more"></span>

<h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>最基本的就是_本地协议（Local protocol）_，所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录。这常见于团队每一个成员都对一个共享的文件系统（例如 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。后面一种情况并不安全，因为所有代码仓库实例都储存在同一台电脑里，增加了灾难性数据损失 的可能性。</p>
<p>如果你使用一个共享的文件系统，就可以在一个本地文件系统中克隆仓库，推送和获取。克隆的时候只需要将远程仓库的路径作为 URL 使用，比如下面这样：</p>
<blockquote>
<p>$ git clone /opt/git/project.git</p>
</blockquote>
<p>或者这样：</p>
<blockquote>
<p>$ git clone file:///opt/git/project.git</p>
</blockquote>
<p>如果在 URL 开头明确使用 file:// ，那么 Git 会以一种略微不同的方式运行。如果你只给出路径，Git 会尝试使用硬链接或直接复制它所需要的文件。如果使用了file:// ，Git 会调用它平时通过网络来传输数据的工序，而这种方式的效率相对较低。使用 file:// 前缀的主要原因是当你需要一个不包含无关引用或对象的干净仓库副本的时候 — 一般指从其他版本控制系统导入的，或类似情形（参见第 9 章的维护任务）。我们这里仅仅使用普通路径，这样更快。</p>
<p>要添加一个本地仓库作为现有 Git 项目的远程仓库，可以这样做：</p>
<blockquote>
<p>$ git remote add local_proj /opt/git/project.git</p>
</blockquote>
<p>然后就可以像在网络上一样向这个远程仓库推送和获取数据了。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>基于文件仓库的优点在于它的简单，同时保留了现存文件的权限和网络访问权限。如果你的团队已经有一个全体共享的文件系统，建立仓库就十分容易了。你 只需把一份裸仓库的副本放在大家都能访问的地方，然后像对其他共享目录一样设置读写权限就可以了。我们将在下一节“在服务器上部署 Git ”中讨论如何导出一个裸仓库的副本。</p>
<p>这也是从别人工作目录中获取工作成果的快捷方法。假如你和你的同事在一个项目中合作，他们想让你检出一些东西的时候，运行类似 git pull /home/john/project 通常会比他们推送到服务器，而你再从服务器获取简单得多。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>这种方法的缺点是，与基本的网络连接访问相比，难以控制从不同位置来的访问权限。如果你想从家里的笔记本电脑上推送，就要先挂载远程硬盘，这和基于网络连接的访问相比更加困难和缓慢。</p>
<p>另一个很重要的问题是该方法不一定就是最快的，尤其是对于共享挂载的文件系统。本地仓库只有在你对数据访问速度快的时候才快。在同一个服务器上，如果二者同时允许 Git 访问本地硬盘，通过 NFS 访问仓库通常会比 SSH 慢。</p>
<h4 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h4><p>Git 使用的传输协议中最常见的可能就是 SSH 了。这是因为大多数环境已经支持通过 SSH 对服务器的访问 — 即便还没有，架设起来也很容易。SSH 也是唯一一个同时支持读写操作的网络协议。另外两个网络协议（HTTP 和 Git）通常都是只读的，所以虽然二者对大多数人都可用，但执行写操作时还是需要 SSH。SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。</p>
<p>通过 SSH 克隆一个 Git 仓库，你可以像下面这样给出 ssh:// 的 URL：</p>
<blockquote>
<p>$ git clone ssh://user@server:project.git</p>
</blockquote>
<p>或者不指明某个协议 — 这时 Git 会默认使用 SSH ：</p>
<blockquote>
<p>$ git clone user@server:project.git</p>
</blockquote>
<p>如果不指明用户，Git 会默认使用当前登录的用户名连接服务器。</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>使用 SSH 的好处有很多。首先，如果你想拥有对网络仓库的写权限，基本上不可能不使用 SSH。其次，SSH 架设相对比较简单 — SSH 守护进程很常见，很多网络管理员都有一些使用经验，而且很多操作系统都自带了它或者相关的管理工具。再次，通过 SSH 进行访问是安全的 — 所有数据传输都是加密和授权的。最后，和 Git 及本地协议一样，SSH 也很高效，会在传输之前尽可能压缩数据。</p>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>SSH 的限制在于你不能通过它实现仓库的匿名访问。即使仅为读取数据，人们也必须在能通过 SSH 访问主机的前提下才能访问仓库，这使得 SSH 不利于开源的项目。如果你仅仅在公司网络里使用，SSH 可能是你唯一需要使用的协议。如果想允许对项目的匿名只读访问，那么除了为自己推送而架设 SSH 协议之外，还需要支持其他协议以便他人访问读取。</p>
<h4 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h4><p>接下来是 Git 协议。这是一个包含在 Git 软件包中的特殊守护进程； 它会监听一个提供类似于 SSH 服务的特定端口（9418），而无需任何授权。打算支持 Git 协议的仓库，需要先创建git-export-daemon-ok 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。要么所有人都能克隆 Git 仓库，要么谁也不能。这也意味着该协议通常不能用来进行推送。你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目 URL 的人将都有推送权限。不用说，这是十分罕见的情况。</p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>Git 协议是现存最快的传输协议。如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个 Git 守护进程来供应仓库是个不错的选择。它使用与 SSH 协议相同的数据传输机制，但省去了加密和授权的开销。</p>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 接口，让几个开发者拥有推送（写）权限，其他人通过git:// 拥有只读权限。Git 协议可能也是最难架设的协议。它要求有单独的守护进程，需要定制 — 我们将在本章的 “Gitosis” 一节详细介绍它的架设 — 需要设定xinetd 或类似的程序，而这些工作就没那么轻松了。该协议还要求防火墙开放 9418 端口，而企业级防火墙一般不允许对这个非标准端口的访问。大型企业级防火墙通常会封锁这个少见的端口。</p>
<h4 id="HTTP-S-协议"><a href="#HTTP-S-协议" class="headerlink" title="HTTP/S 协议"></a>HTTP/S 协议</h4><p>最后还有 HTTP 协议。HTTP 或 HTTPS 协议的优美之处在于架设的简便性。基本上，只需要把 Git 的裸仓库文件放在 HTTP 的根目录下，配置一个特定的post-update 挂钩（hook）就可以搞定（Git 挂钩的细节见第 7 章）。此后，每个能访问 Git 仓库所在服务器上 web 服务的人都可以进行克隆操作。下面的操作可以允许通过 HTTP 对仓库进行读取：</p>
<blockquote>
<p>$ cd /var/www/htdocs/</p>
</blockquote>
<blockquote>
<p>$ git clone –bare /path/to/git_project gitproject.git</p>
</blockquote>
<blockquote>
<p>$ cd gitproject.git</p>
</blockquote>
<blockquote>
<p>$ mv hooks/post-update.sample hooks/post-update</p>
</blockquote>
<blockquote>
<p>$ chmod a+x hooks/post-update</p>
</blockquote>
<p>这样就可以了。Git 附带的 post-update 挂钩会默认运行合适的命令（git update-server-info）来确保通过 HTTP 的获取和克隆正常工作。这条命令在你用 SSH 向仓库推送内容时运行；之后，其他人就可以用下面的命令来克隆仓库：</p>
<blockquote>
<p>$ git clone <a href="http://example.com/gitproject.git">http://example.com/gitproject.git</a></p>
</blockquote>
<p>在本例中，我们使用了 Apache 设定中常用的 /var/www/htdocs 路径，不过你可以使用任何静态 web 服务 — 把裸仓库放在它的目录里就行。 Git 的数据是以最基本的静态文件的形式提供的（关于如何提供文件的详情见第 9 章）。</p>
<p>通过 HTTP 进行推送操作也是可能的，不过这种做法不太常见，并且牵扯到复杂的 WebDAV 设定。由于很少用到，本书将略过对该内容的讨论。如果对 HTTP 推送协议感兴趣，不妨打开这个地址看一下操作方法：<a href="http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt">http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt</a> 。通过 HTTP 推送的好处之一是你可以使用任何 WebDAV 服务器，不需要为 Git 设定特殊环境；所以如果主机提供商支持通过 WebDAV 更新网站内容，你也可以使用这项功能。</p>
<h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><p>使用 HTTP 协议的好处是易于架设。几条必要的命令就可以让全世界读取到仓库的内容。花费不过几分钟。HTTP 协议不会占用过多服务器资源。因为它一般只用到静态的 HTTP 服务提供所有数据，普通的 Apache 服务器平均每秒能支撑数千个文件的并发访问 — 哪怕让一个小型服务器超载都很难。</p>
<p>你也可以通过 HTTPS 提供只读的仓库，这意味着你可以加密传输内容；你甚至可以要求客户端使用特定签名的 SSL 证书。一般情况下，如果到了这一步，使用 SSH 公共密钥可能是更简单的方案；不过也存在一些特殊情况，这时通过 HTTPS 使用带签名的 SSL 证书或者其他基于 HTTP 的只读连接授权方式是更好的解决方案。</p>
<p>HTTP 还有个额外的好处：HTTP 是一个如此常见的协议，以至于企业级防火墙通常都允许其端口的通信。</p>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>HTTP 协议的消极面在于，相对来说客户端效率更低。克隆或者下载仓库内容可能会花费更多时间，而且 HTTP 传输的体积和网络开销比其他任何一个协议都大。因为它没有按需供应的能力 — 传输过程中没有服务端的动态计算 — 因而 HTTP 协议经常会被称为_傻瓜（dumb）_协议。更多 HTTP 协议和其他协议效率</p>
<p>转发：<a href="https://blog.csdn.net/return_cc/article/details/78419533">https://blog.csdn.net/return_cc/article/details/78419533</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>代码管理</tag>
      </tags>
  </entry>
  <entry>
    <title>使用git分支管理hexo博客源码</title>
    <url>//25/</url>
    <content><![CDATA[<h3 id="使用git分支管理hexo博客源码"><a href="#使用git分支管理hexo博客源码" class="headerlink" title="使用git分支管理hexo博客源码"></a>使用git分支管理hexo博客源码</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>使用hexo写博客的流程通常是：</p>
<ol>
<li>通过hexo new post_name命令，会自动在source/_post目录下生成一个待写的post_name.md文件；</li>
<li>编写完该md文件后，用hexo generate编译生成对应的HTML文件；</li>
<li>发布之前，可以用hexo s本地预览，然后通过hexo deploy发布到远程仓库的master分支，然后你的个人站点就能看到刚才新加的文章了。</li>
</ol>
<p>然而，远程仓库只会保存hexo发布后的静态HTML文件，博客md源文件、主题配置等还在本地，一旦电脑磁盘坏了或者换了电脑，就无法在之前仓库的基础上继续写博客。</p>
<span id="more"></span>

<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="新建git分支"><a href="#新建git分支" class="headerlink" title="新建git分支"></a>新建git分支</h5><p>Github Page要求使用master分支作为发布网站的源代码，我们只能用master分支来保存hexo生成的静态网页，所以可以新建一个dev分支来保存源代码。</p>
<p>如图在红框位置输入需要新建的分支名就会提示新建分支，此处我已经新建，故直接显示dev分支。</p>
<p><img src="/25/25-1.png" alt="&#39;新建分支&#39;"></p>
<p>此时建立的分支是从master分支克隆过来的，因而master中已有的public等deploy生成的文件也会一起带过来，这些都不算是博客源文件。可以先在本地把它删掉，然后提交推送到GitHub上的dev分支</p>
<blockquote>
<p>git add .<br>git commit -m ‘删除public文件’<br>git push origin dev</p>
</blockquote>
<h5 id="更改仓库的默认分支"><a href="#更改仓库的默认分支" class="headerlink" title="更改仓库的默认分支"></a>更改仓库的默认分支</h5><p>github上的仓库初始都会有个master分支，也就是默认分支。<br>对于一个仓库project_name，当我们通过</p>
<blockquote>
<p>git clone <a href="https://github.com/sherlockyb/project_name.git">https://github.com/sherlockyb/project_name.git</a></p>
</blockquote>
<p>下载代码时，实际拉取的是默认分支master对应的代码。<br>而我们用hexo写博客时，通常是与md源文件打交道，对于deploy生成的master分支代码并不需要我们关注，因此可将仓库的默认分支改为保存源码的dev分支，这样通过git clone拉取的就是dev分支代码了。</p>
<p>在仓库的主页面，通过Settings -&gt; Branchs，可以看到Default branch的Tab，显示的默认分支是master，可以勾选dev，然后update即可将默认分支设置为dev，如下图：</p>
<p><img src="/25/25-2.png" alt="&#39;更改仓库的默认分支&#39;"></p>
<h5 id="推送博客源码"><a href="#推送博客源码" class="headerlink" title="推送博客源码"></a>推送博客源码</h5><p>将本地的md源文件、站点配置文件等推送到source分支。</p>
<p>因为我们只需要保留博客源码，其他无关的文件并不希望推送，需要确保配好了.gitignore文件，通常如下：</p>
<blockquote>
<p>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</p>
</blockquote>
<p>然后执行:</p>
<blockquote>
<p>git add .<br>git commit -m ‘新增博客’<br>git push origin dev</p>
</blockquote>
<p>将源代码修改已经新增的博客md上传到dev分支</p>
<h5 id="新环境"><a href="#新环境" class="headerlink" title="新环境"></a>新环境</h5><p>假设我们换电脑了，要在新环境继续在原有仓库基础上撸文章，此时通过git clone将博客源码拉到本地，然后安装、初始化hexo就能搞定。</p>
<p>转发：<a href="https://blog.csdn.net/weixin_29164081/article/details/112712581">https://blog.csdn.net/weixin_29164081/article/details/112712581</a></p>
<p>git push –set-upstream origin dev<br>git pull –rebase origin dev<br>git remote set-url origin <a href="https://github.com/xdw-h/xdw-h.github.io.git">https://github.com/xdw-h/xdw-h.github.io.git</a><br>git remote add origin <a href="https://github.com/xdw-h/xdw-h.github.io.git">https://github.com/xdw-h/xdw-h.github.io.git</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>代码管理</tag>
      </tags>
  </entry>
  <entry>
    <title>reflow(回流)和repaint(重绘)</title>
    <url>//26/</url>
    <content><![CDATA[<h3 id="reflow-回流-和repaint-重绘"><a href="#reflow-回流-和repaint-重绘" class="headerlink" title="reflow(回流)和repaint(重绘)"></a>reflow(回流)和repaint(重绘)</h3><h4 id="render-tree"><a href="#render-tree" class="headerlink" title="render tree"></a>render tree</h4><p>DOM Tree 和样式结构体组合后构建render tree</p>
<h4 id="回流-reflow"><a href="#回流-reflow" class="headerlink" title="回流(reflow)"></a>回流(reflow)</h4><ol>
<li>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)；</li>
<li>每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。</li>
</ol>
<span id="more"></span>

<h4 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(repaint)</h4><ol>
<li>在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘；</li>
<li>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘()。</li>
</ol>
<h4 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h4><ol>
<li>回流必将引起重绘，而重绘不一定会引起回流；</li>
<li>当页面布局和几何属性改变时就需要回流，比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变；</li>
<li>回流的花销跟render tree有多少节点需要重新构建有关系；</li>
<li>浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush（清空）队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</li>
</ol>
<h4 id="cssText的使用场景"><a href="#cssText的使用场景" class="headerlink" title="cssText的使用场景"></a>cssText的使用场景</h4><p>有时我们需要使用原生js写css样式，比如</p>
<blockquote>
<p>obj.style.width = ‘100px’;<br>obj.style.height = ‘100px’; </p>
</blockquote>
<p>这种写法1, 2个样式还好，当出现多个样式时，这种写法就会显得比较繁琐，并且js覆写样式是会销毁原样式并重建的过程，这种销毁和重建，都会增加浏览器的开销。</p>
<ol>
<li>这时我们可以使用cssText属性进行累加:</li>
</ol>
<blockquote>
<p>ele.style.cssText += ‘width: 100px; height: 100px; color: #000; font-size: 14px; background: #ccc’; </p>
</blockquote>
<p>但是，cssText（假如不为空）在IE中最后一个分号会被删掉， 可以在前面添加一个分号来解决这个问题</p>
<blockquote>
<p>ele.style.cssText += ‘; width: 100px; height: 100px; color: #000; font-size: 14px; background: #ccc’; </p>
</blockquote>
<ol start="2">
<li>可以先把dom的display置为none，等所有样式修改完，再置为block，虽然也会引起回流，但减少了回流次数。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTML、CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>常见单位：px、em、rem、vw、vh及之前区别，使用</title>
    <url>//27/</url>
    <content><![CDATA[<h3 id="常见单位：px、em、rem、vw、vh及之前区别，使用"><a href="#常见单位：px、em、rem、vw、vh及之前区别，使用" class="headerlink" title="常见单位：px、em、rem、vw、vh及之前区别，使用"></a>常见单位：px、em、rem、vw、vh及之前区别，使用</h3><h4 id="px"><a href="#px" class="headerlink" title="px"></a>px</h4><p>px：绝对单位，页面按精确像素展示</p>
<h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</p>
<span id="more"></span>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>body</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>div1</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>div2</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div3&quot;</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>计算关系是这样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>body的font-size是继承自跟元素html，html的尺寸是浏览器默认尺寸14px；<br>div1的font-size=1.5<em>14px = 21px;<br>div2的font-size=1.5</em>21px = 31.5px;<br>div3的font-size=1.5*31.5px = 47.25px; </p>
<h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。<br>(另外需注意chrome强制最小字体为12号，即使设置成 10px 最终都会显示成 12px，当把html的font-size设置成10px, 子节点rem的计算还是以12px为基准)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div3</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时div3的font-size = 1.5<em>14px = 1.5</em>html的font-size</p>
<p>在所有现代浏览器中，其默认的字体大小就是“16px”。因此在浏览器下默认的设置将是：<br>1em = 16px</p>
<hr>
<p>使用vw，vh时，需设置meta缩放比1:1</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="vw"><a href="#vw" class="headerlink" title="vw"></a>vw</h4><p>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</p>
<h4 id="vh"><a href="#vh" class="headerlink" title="vh"></a>vh</h4><p>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</p>
<h4 id="vmin"><a href="#vmin" class="headerlink" title="vmin"></a>vmin</h4><p>vmin：vw和vh中较小的那个。</p>
<h4 id="vmax"><a href="#vmax" class="headerlink" title="vmax"></a>vmax</h4><p>vmax：vw和vh中较大的那个。</p>
<ol>
<li>相对于视口的高度和宽度，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。</li>
<li>比如：浏览器高度900px，宽度为750px, 1 vh = 900px/100 = 9 px，1vw = 750px/100 = 7.5 px。</li>
<li>很容易实现与同屏幕等高的框：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.slide</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>设置一个和屏幕同宽的标题，</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100vw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果。<br>5. vmin and vmax：关于视口高度和宽度两者的最小值或者最大值。<br>6. 浏览器的宽度设置为1200px，高度设置为800px， 1vmax = 1200/100px = 12px， 1vmin = 800/100px = 8px。如果宽度设置为600px, 高度设置为1080px, 1vmin就等于6px, 1vmax则未10.8px。<br>7. 有一个元素，你需要让它始终在屏幕上可见：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vmin</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vmin</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>如果你要让这个元素始终铺满整个视口的可见区域：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vmax</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vmax</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTML、CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>BFC相关概念</title>
    <url>//28/</url>
    <content><![CDATA[<h3 id="BFC相关概念"><a href="#BFC相关概念" class="headerlink" title="BFC相关概念"></a>BFC相关概念</h3><p>一个块格式化上下文（block formatting context）是Web页面的可视化CSS渲染的一部分。用于决定块盒子的布局及浮动相互影响范围的一个区域。</p>
<span id="more"></span>

<ul>
<li>触发BFC<ul>
<li>body 根元素</li>
<li>浮动元素：float除none以外的值</li>
<li>绝对定位元素：position(absolute、fixed）</li>
<li>display为inline-block、table-cells、flex</li>
<li>overflow除了visible以外的值(hidden、auto、scroll)</li>
</ul>
</li>
<li>特点<ul>
<li>内部块级盒子垂直方向排列</li>
<li>盒子垂直距离由margin决定，同一个BFC盒子的外边距会-重叠</li>
<li>BFC就是一个隔离的容器，内部子元素不会影响到外部元素</li>
<li>BFC 的区域不会与float box叠加</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>元素A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>元素B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/28/28-1.png" alt="&#39;28-1&#39;"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTML、CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Event Loop</title>
    <url>//29/</url>
    <content><![CDATA[<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Event Loop是一个程序结构，用于等待和发送消息和事件。</p>
<blockquote>
<p>简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。</p>
</blockquote>
<span id="more"></span>

<p>上图主线程的绿色部分，还是表示运行时间，而橙色部分表示空闲时间。每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。</p>
<h4 id="event-loop-的执行规则："><a href="#event-loop-的执行规则：" class="headerlink" title="event loop 的执行规则："></a>event loop 的执行规则：</h4><ol>
<li>首先执行宏任务，这个宏任务一般指 主干代码，我们经常称之为同步代码；</li>
<li>执行过程中如果遇到了微任务，将其加入到微任务队列中；</li>
<li>执行完宏任务之后，开始执行微任务队列中的任务，直至微任务队列为空；</li>
<li>微任务执行完之后，开始执行下一个宏任务；</li>
<li>如何循环执行，直到宏任务和微任务都执行完。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>postman安装使用</title>
    <url>//3/</url>
    <content><![CDATA[<h3 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h3><h4 id="下载链接：https-www-postman-com-downloads"><a href="#下载链接：https-www-postman-com-downloads" class="headerlink" title="下载链接：https://www.postman.com/downloads/"></a>下载链接：<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></h4><span id="more"></span>

<h3 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h3><p><img src="/3/3-1.PNG" alt="3-1"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>点击 图中的 Create New 创建自己的 workspaces ，用来存放自己要测试接口</p>
<p><img src="/3/3-2.PNG" alt="3-2"></p>
<p>点击 Create a request 创建请求</p>
<p><img src="/3/3-3.PNG" alt="3-3"></p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>postman</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo next主题增加搜索功能</title>
    <url>//30/</url>
    <content><![CDATA[<h3 id="hexo-增加搜索功能"><a href="#hexo-增加搜索功能" class="headerlink" title="hexo 增加搜索功能"></a>hexo 增加搜索功能</h3><p>首先进入hexo工程目录，输入</p>
<blockquote>
<p>npm install hexo-generator-searchdb –save</p>
</blockquote>
<span id="more"></span>

<p>然后进入themes\next_config.yml，搜索 Local search</p>
<p>设置</p>
<blockquote>
<p>local_search:<br>enable: true</p>
</blockquote>
<p>进入根目录的_config.yml，增加</p>
<blockquote>
<p>search:<br>path: search.xml   #在public目录的根目录下生成search.xml 文件，用于存储网站文章的文字数据.<br>field: post<br>format: html<br>limit: 10000</p>
</blockquote>
<p>同时在根目录的_config.yml搜索URL，将permalink的值最前面加上/, 表示每次跳转的页面都是相对于根路径，就不会出现地址重复导致404的问题</p>
<blockquote>
<p>permalink: /:year/:month/:day/:title/ </p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS</title>
    <url>//32/</url>
    <content><![CDATA[<h3 id="HTTP-1-0、HTTP-1-1、HTTP-2、HTTPS"><a href="#HTTP-1-0、HTTP-1-1、HTTP-2、HTTPS" class="headerlink" title="HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS"></a>HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS</h3><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><p>HTTP（超文本传输协议，HyperText Transfer Protocol)是建立在TCP协议之上的一种应用层网络协议。默认使用80端口，建立之初目的是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。</p>
<span id="more"></span>

<h4 id="HTTP-1-1-和-HTTP-1-0-的区别"><a href="#HTTP-1-1-和-HTTP-1-0-的区别" class="headerlink" title="HTTP/1.1 和 HTTP/1.0 的区别"></a>HTTP/1.1 和 HTTP/1.0 的区别</h4><ol>
<li><p>缓存处理：HTTP/1.0 使用 Pragma:no-cache + Last-Modified/If-Modified-Since来作为缓存判断的标准；HTTP/1.1 引入了更多的缓存控制策略：Cache-Control、Etag/If-None-Match等。</p>
</li>
<li><p>错误状态管理：HTTP/1.1新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
<li><p>范围请求：HTTP/1.1在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接，支持断点续传。</p>
</li>
<li><p>Host头：HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>
</li>
<li><p>持久连接：HTTP/1.1 最大的变化就是引入了持久连接（persistent connection），在HTTP/1.1中默认开启 Connection: keep-alive，即TCP连接默认不关闭，可以被多个请求复用。</p>
</li>
</ol>
<p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。</p>
<ol start="6">
<li>管道机制：HTTP/1.1中引入了管道机制（pipelining）,即在同一个TCP连接中，客户端可以同时发送多个请求。</li>
</ol>
<h4 id="HTTP-1-1的缺点"><a href="#HTTP-1-1的缺点" class="headerlink" title="HTTP/1.1的缺点"></a>HTTP/1.1的缺点</h4><p>HTTP/1.1 的持久连接和管道机制允许复用TCP连接，在一个TCP连接中，也可以同时发送多个请求，但是所有的数据通信都是按次序完成的，服务器只有处理完一个回应，才会处理下一个回应。比如客户端需要A、B两个资源，管道机制允许浏览器同时发出A请求和B请求，但服务器还是按照顺序，先回应A请求，完成后再回应B请求，这样如果前面的回应特别慢，后面就会有很多请求排队等着，这称为“队头阻塞（Head-of-line blocking）”</p>
<h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h4><p>HTTP/2以Google发布的SPDY协议为基础，于2015年发布。它不叫HTTP/2.0，因为标准委员会不打算再发布子版本了，下一个新版本将是HTTP/3。HTTP/2协议只在HTTPS环境下才有效，升级到HTTP/2，必须先启用HTTPS。HTTP/2解决了HTTP/1.1的性能问题，主要特点如下：</p>
<ol>
<li><p>二进制分帧：HTTP/1.1的头信息是文本（ASCII编码），数据体可以是文本，也可以是二进制；HTTP/2 头信息和数据体都是二进制，统称为“帧”：头信息帧和数据帧；</p>
</li>
<li><p>多路复用（双工通信）：通过单一的 HTTP/2 连接发起多重的请求-响应消息，即在一个连接里，客户端和浏览器都可以同时发送多个请求和响应，而不用按照顺序一一对应，这样避免了“队头堵塞”。HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。</p>
</li>
<li><p>数据流：因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。HTTP/1.1取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>
</li>
<li><p>首部压缩：HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息压缩后再发送（SPDY 使用的是通用的DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法）。；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
</li>
<li><p>服务端推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>
</li>
</ol>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>HTTPS可以说是安全版的HTTP，HTTPS基于安全SSL/TLS（安全套接层Secure Sockets Layer/安全传输层Transport Layer Security）层，即在传统的HTTP和TCP之间加了一层用于加密解密的SSL/TLS层。HTTP默认使用80端口，HTTPS默认使用443端口。</p>
<p>不使用SSL/TLS的HTTP通信，所有信息明文传播，会带来三大风险：</p>
<p>窃听风险：第三方可以获取通信内容；<br>篡改风险：第三方可以修改通信内容；<br>冒充风险：第三方可以冒充他人进行通信。<br>SSL/TLS协议是为了解决这三大风险而设计的，以期达到：</p>
<p>信息加密传输：第三方无法窃听；<br>校验机制：一旦被篡改，通信双方会立刻发现；<br>身份证书：防止身份被冒充。</p>
<h4 id="SSL-TLS运行机制"><a href="#SSL-TLS运行机制" class="headerlink" title="SSL/TLS运行机制"></a>SSL/TLS运行机制</h4><p>SSL/TLS的基本思路是公钥加密法：客户端先向服务器索要并验证公钥，然后用公钥加密传输来协商生成“对话秘钥”（非对称加密），双方采用“对话秘钥”进行加密通信（对称加密）。</p>
<p>通信过程如下：</p>
<ol>
<li><p>客户端发出请求：给出支持的协议版本、支持的加密方法（如RSA公钥加密）以及一个客户端生成的随机数（Client random）；</p>
</li>
<li><p>服务端回应：确认双方通信的协议版本、加密方法，并给出服务器证书以及一个服务器生成的随机数（Server random）；</p>
</li>
<li><p>客户端回应：客户端确认证书有效，取出证书中的公钥，然后生成一个新的随机数（Premaster secret），使用公钥加密这个随机数，发送给服务端；</p>
</li>
<li><p>服务端回应：服务端使用自己的私钥解密客户端发来的随机数（Premaster secret），客户端和服务端根据约定的加密方法，使用三个随机数，生成“对话秘钥”；</p>
</li>
<li><p>会话通信：客户端和服务端使用“对话秘钥”加密通信，这个过程完全使用普通的HTTP协议，只不过用“会话秘钥”加密内容。</p>
</li>
</ol>
<h4 id="HTTPS特点"><a href="#HTTPS特点" class="headerlink" title="HTTPS特点"></a>HTTPS特点</h4><p>缓存：只要在HTTP头中使用特定命令，就可以缓存HTTPS；<br>延迟：HTTP耗时 = TCP握手；HTTPS耗时 = TCP握手 + SSL握手。SSL握手耗时大概是TCP握手耗时的三倍左右。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码（HTTP Status Code）</title>
    <url>//31/</url>
    <content><![CDATA[<h3 id="HTTP状态码（HTTP-Status-Code）"><a href="#HTTP状态码（HTTP-Status-Code）" class="headerlink" title="HTTP状态码（HTTP Status Code）"></a>HTTP状态码（HTTP Status Code）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。</p>
<span id="more"></span>

<h4 id="常见的HTTP状态码"><a href="#常见的HTTP状态码" class="headerlink" title="常见的HTTP状态码"></a>常见的HTTP状态码</h4><ol>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ol>
<h4 id="HTTP状态码分类"><a href="#HTTP状态码分类" class="headerlink" title="HTTP状态码分类"></a>HTTP状态码分类</h4><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody><tr>
<td>1**</td>
<td>信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td>2**</td>
<td>成功，操作被成功接收并处理</td>
</tr>
<tr>
<td>3**</td>
<td>重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td>4**</td>
<td>客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td>5**</td>
<td>服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<h4 id="HTTP状态码列表"><a href="#HTTP状态码列表" class="headerlink" title="HTTP状态码列表"></a>HTTP状态码列表</h4><table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>继续。客户端应继续其请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<p>转发：<a href="https://www.runoob.com/http/http-status-codes.html">https://www.runoob.com/http/http-status-codes.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS定位相关知识：static、relative、absolute</title>
    <url>//33/</url>
    <content><![CDATA[<h3 id="CSS定位相关知识：static、relative、absolute"><a href="#CSS定位相关知识：static、relative、absolute" class="headerlink" title="CSS定位相关知识：static、relative、absolute"></a>CSS定位相关知识：static、relative、absolute</h3><h4 id="position可选值"><a href="#position可选值" class="headerlink" title="position可选值"></a>position可选值</h4><ol>
<li>static 默认值，元素是静止的，没有开启定位，写与不写没有区别；</li>
<li>relative 开启元素的相对定位；</li>
<li>absolute 开启元素的绝对定位；</li>
<li>fixed 开启元素的固定定位；</li>
<li>sticky 开启元素的粘滞定位；</li>
</ol>
<span id="more"></span>

<h4 id="文档流-定位方式"><a href="#文档流-定位方式" class="headerlink" title="文档流 定位方式"></a>文档流 定位方式</h4><ol>
<li>在html中，默认使用流式布局</li>
<li>流式布局：在一个html中每个元素都有自己的位置，行元素和行内块元素从左到右，块元素从上到下的布局方式<br>文档流：在一个页面中，在文档流中的元素都有自己的位置，如果某个元素脱离了文档流，那么它将不再参与流式布局，不再拥有自己的位置。</li>
<li>块元素：如果脱离了文档流，那么它将不再参照父元素的宽度定宽，所以脱离文档流的块元素，如果没有内容，则必须设置宽高，如果有内容，那么它的宽高将取决于它内容的宽高。</li>
</ol>
<h4 id="position表示元素的定位方式"><a href="#position表示元素的定位方式" class="headerlink" title="position表示元素的定位方式"></a>position表示元素的定位方式</h4><ol>
<li><p>static<br>表示静态定位，也是元素默认的定位方式，参与流式布局（在文档流中），不能设置位置</p>
</li>
<li><p>relative<br>表示相对定位（相对于自身原有的位置进行定位的）, 不会脱离文档流，依旧参与流式布局，原有的位置依旧还在</p>
</li>
<li><p>absolute<br>表示绝对定位（绝对定位会使元素脱离文档流，不再参与流式布局，即在文档流中不再拥有自己的位置）, 它会先查看它的父元素是否为静态定位static(也就是没有设置定位)，如果不是，就相对于父元素进行定位，如果是静态定位static(也就是没有设置定位)，那么就查看它父元素的父元素是否为静态定位，一直查找到不是静态定位为止，如果查找到html都为静态定位，就相对于html页面进行定位。<br>所以，如果想让一个元素相对于它的父元素进行定位，那么就把它的父元素定位方式设置成非静态定位即可，一般情况下设置成relative相对定位，因为相对定位不会破坏父元素的流式布局</p>
</li>
<li><p>fixed<br>表示固定定位，会使元素脱离文档流，不再参与流式布局，在文档流中将没有它的位置</p>
</li>
</ol>
<h4 id="相对定位的特点："><a href="#相对定位的特点：" class="headerlink" title="相对定位的特点："></a>相对定位的特点：</h4><ol>
<li>元素开启相对定位后，如果不设置偏移量元素不会发生任何变化；</li>
<li>相对定位是参照于元素在文档流中的位置来定位的；</li>
<li>相对定位会提升元素的层级；</li>
<li>相对定位不会使元素脱离文档流；</li>
<li>相对定位不会改变元素的性质，块还是块，行内还是行内；</li>
</ol>
<h4 id="绝对定位的特点："><a href="#绝对定位的特点：" class="headerlink" title="绝对定位的特点："></a>绝对定位的特点：</h4><ol>
<li>开启绝对定位后，如果不设置偏移量元素的位置不会发生变化；</li>
<li>元素会从文档流中脱离；</li>
<li>绝对定位会改变元素的性质，因为脱离文档流了，行内变成块，块的高度被内容撑开；</li>
<li>绝对定位会使元素提升一个层级；</li>
<li>绝对定位元素是相对于其包含块进行定位的。</li>
</ol>
<h4 id="包含块containing-block："><a href="#包含块containing-block：" class="headerlink" title="包含块containing block："></a>包含块containing block：</h4><ol>
<li>正常情况下：包含块就是离当前元素最近的祖先块元素；</li>
<li>开启绝对定位情况下：包含块就是离他最近的开启了定位的祖先元素；如果所有的祖先元素都没有开启定位，则相对于根元素进行定位；<br>html–叫根元素，也叫初始包含块；</li>
</ol>
<h4 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h4><ol>
<li>固定定位：position的属性定义为fixed则开启了元素的固定定位；固定定位也是一种绝对定位，所以固定定位的大部分特点和绝对定位一样。固定定位是一种特殊的决定定位；</li>
<li>和绝对定位不同 的特点：<br>唯一不用的是固定定位永远参照于浏览器的视口进行定位；固定定位的元素不会随网页的滚动条滚动。<br>使用场景：广告条等。</li>
</ol>
<h4 id="粘滞定位"><a href="#粘滞定位" class="headerlink" title="粘滞定位"></a>粘滞定位</h4><ol>
<li>粘滞定位是比较新的定位方法，老的浏览器可能不支持。粘滞定位和相对定位比较相近。当一个元素滚动到一定高度的时候就不动了。</li>
<li>当开启了决定定位后，水平方向的布局等式就要添加left和right两个值，规则和之前一样，只是多添加了2个值。当发生过度约束，9个值中没有auto，则自动调整right值以使等式满足。如果有auto，则自动调整auto的值。<br>可以设置auto的有：margin width left right。</li>
<li>因为left和right默认值是auto，如果不设置left和right，则等式不满足时，会自动调整这两个值。</li>
</ol>
<h4 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h4><ol>
<li>对于开启了定位的元素，可以通过z-index属性来指定元素的层级，z-index需要一个整数作为参数，值越大元素的层级越高，元素的层级越高越优先显示。</li>
<li>如果元素的层级一样，优先显示靠下的元素。</li>
<li>祖先元素的层级再高也不会盖住后代元素。祖先元素永远盖不住后代元素。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTML、CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖 &amp; 节流 的原理及应用场景</title>
    <url>//34/</url>
    <content><![CDATA[<h3 id="防抖-amp-节流-的原理及应用场景"><a href="#防抖-amp-节流-的原理及应用场景" class="headerlink" title="防抖 &amp; 节流 的原理及应用场景"></a>防抖 &amp; 节流 的原理及应用场景</h3><p>函数防抖和函数节流都用于优化事件处理程序，解决短时间内大量触发某函数而导致的性能问题，比如触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或者卡顿的现象，但是二者的业务需求是不一样的。</p>
<span id="more"></span>

<h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><ol>
<li>含义：一个频繁触发的函数，在规定时间内，只让最后一次生效，前面的不生效。（无论触发多少次，只执行一次）</li>
<li>原理：在第一次调用函数时，创建一个定时器，在指定的时间间隔后运行代码；如果代码还没运行时，又触发了该函数，则清除旧的定时器，重新创建新的定时器；如果超过延时执行的时间，代码执行了，则此时已经是第二次触发了。</li>
<li>应用场景：频繁操作点赞和取消点赞的时候；search搜索联想，用户在不断输入值时</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***   debounce:防抖函数     + params: func（要被触发的函数）               delay(指定的时间)     + return [function] ***/</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func, delay</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func();</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>案例</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;normal&quot;</span> <span class="attr">id</span>=<span class="string">&quot;normal&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        ~ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">content</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;ajax request&#x27;</span> + content);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">clearTimeout</span>(timer);</span></span><br><span class="line"><span class="javascript">                    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                        func.apply(<span class="built_in">this</span>, args);</span></span><br><span class="line">                    &#125;, delay)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> input = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#normal&quot;</span>);</span></span><br><span class="line">            debounceTask = debounce(ajax, 1000)</span><br><span class="line"><span class="javascript">            input.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line">                debounceTask(e.target.value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><ol>
<li>含义：一个频繁触发的函数，在规定时间内，函数执行一次后，只有大于设定的执行周期才会执行第二次。（减少触发执行的频率）</li>
<li>原理：第一次执行函数的时候，记录函数执行的时间，当下一次执行的时候，比较时间是否还在间隔时间内，如果是则不执行，否则继续执行；</li>
<li>应用场景：一般在onresize/mousemove/onscroll等事件中，防止过多的请求造成服务器压力</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment">  throttle:节流函数</span></span><br><span class="line"><span class="comment">    + params: func（要被触发的函数）</span></span><br><span class="line"><span class="comment">              delay(指定的时间)</span></span><br><span class="line"><span class="comment">    + return [function] </span></span><br><span class="line"><span class="comment">***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种写法：</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">func, delay</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> nowTime = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">if</span> (nowTime - lastTime &gt; delay) &#123;</span><br><span class="line">            method();</span><br><span class="line">            lastTime = nowTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//第二种写法：</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">func, delay</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>;</span><br><span class="line">        canRun = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func();</span><br><span class="line">            canRun = <span class="literal">true</span>;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>案例</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>节流<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;normal&quot;</span> <span class="attr">id</span>=<span class="string">&quot;normal&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        ~ <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">content</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;ajax request&#x27;</span> + content);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> lastTime = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span></span><br><span class="line">                    if (now - lastTime &gt; delay) &#123;</span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.time();</span></span><br><span class="line"><span class="javascript">                        func.call(<span class="built_in">this</span>, args);</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">console</span>.timeEnd();</span></span><br><span class="line">                        lastTime = now;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> input = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#normal&quot;</span>);</span></span><br><span class="line">            throttleTask = throttle(ajax, 2000)</span><br><span class="line"><span class="javascript">            input.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line">                throttleTask(e.target.value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Token、Cookie、Session</title>
    <url>//35/</url>
    <content><![CDATA[<h3 id="Token、Cookie、Session"><a href="#Token、Cookie、Session" class="headerlink" title="Token、Cookie、Session"></a>Token、Cookie、Session</h3><p>在Web应用中，HTTP请求是无状态的。即：用户第一次发起请求，与服务器建立连接并登录成功后，为了避免每次打开一个页面都需要登录一下，就出现了cookie，Session。</p>
<span id="more"></span>

<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。Cookie存储的数据量有限，且都是保存在客户端浏览器中。不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用Cookie实际上只能存储一小段的文本信息。</p>
<p>例如：登录网站，今输入用户名密码登录了，第二天再打开很多情况下就直接打开了。这个时候用到的一个机制就是Cookie。</p>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Session是另一种记录客户状态的机制，它是在服务端保存的一个数据结构（主要存储的的SessionID和Session内容，同时也包含了很多自定义的内容如：用户基础信息、权限信息、用户机构信息、固定变量等），这个数据可以保存在集群、数据库、文件中，用于跟踪用户的状态。</p>
<p>客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。</p>
<p>用户第一次登录后，浏览器会将用户信息发送给服务器，服务器会为该用户创建一个SessionId，并在响应内容（Cookie）中将该SessionId一并返回给浏览器，浏览器将这些数据保存在本地。当用户再次发送请求时，浏览器会自动的把上次请求存储的Cookie数据自动的携带给服务器。</p>
<p>服务器接收到请求信息后，会通过浏览器请求的数据中的SessionId判断当前是哪个用户，然后根据SessionId在Session库中获取用户的Session数据返回给浏览器。</p>
<p>例如：购物车，添加了商品之后客户端处可以知道添加了哪些商品，而服务器端如何判别呢，所以也需要存储一些信息就用到了Session。</p>
<p>如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p>
<p>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。</p>
<h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>HTTP请求都是以无状态的形式对接。即HTTP服务器不知道本次请求和上一次请求是否有关联。所以就有了Session的引入，即服务端和客户端都保存一段文本，客户端每次发起请求都带着，这样服务器就知道客户端是否发起过请求。</p>
<p>这样，就导致客户端频繁向服务端发出请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否。而Session的存储是需要空间的，频繁的查询数据库给服务器造成很大的压力。</p>
<p>在这种情况下，Token应用而生。</p>
<p>Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌。当客户端第一次访问服务端，服务端会根据传过来的唯一标识userId，运用一些算法，并加上密钥，生成一个Token，然后通过BASE64编码一下之后将这个Token返回给客户端，客户端将Token保存起来（可以通过数据库或文件形式保存本地）。下次请求时，客户端只需要带上Token，服务器收到请求后，会用相同的算法和密钥去验证Token。</p>
<p>最简单的Token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由Token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接Token请求服务器)。</p>
<p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：</p>
<ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者数据库里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li>
<li>APP登录的时候发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果成功，以某种方式比如随机生成32位的字符串作为Token，存储到服务器中，并返回Token到APP，以后APP请求时，凡是需要验证的地方都要带上该Token，然后服务器端验证Token，成功返回所需要的结果，失败返回错误信息，让他重新登录。</li>
</ol>
<p>对于同一个APP同一个手机当前只有一个Token；手机APP会存储一个当前有效的Token。其中服务器上Token设置一个有效期，每次APP请求的时候都验证Token和有效期。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li><p>我们需要知道cookie在客户端，session在服务端，cookie的产生是在服务端产生的</p>
</li>
<li><p>cookie只是一个通行证，但并不是安全的，任何安全的校验必须要在服务端上完成，cookie只是存在客户端上面的一个唯一标识它且由服务端定制的信息，本地可以改，但是不管怎么改，最后还是需要把它拿上发送给服务端进行匹配校验</p>
</li>
<li><p>session和cookie的存储都存在时效性，这是很有必要的</p>
</li>
<li><p>单个cookie保存的数据不能超过4kb，很多浏览器都限制了一个站点最多保存20个cookie</p>
</li>
<li><p>不管是cookie还是session，都是建立在安全性的大前提下，session中不仅仅有cookie的信息，同时会有该用户的相关重要且安全的信息存储，所以session是在服务器的，而cookie只是服务器将一些不重要的信息拿出来丢给客户的存在，以备以后快速匹配校验用。</p>
</li>
</ol>
<p>转发：<br><a href="https://www.cnblogs.com/suguangti/p/11043039.html">https://www.cnblogs.com/suguangti/p/11043039.html</a><br><a href="https://www.cnblogs.com/wzzkaifa/p/7364595.html">https://www.cnblogs.com/wzzkaifa/p/7364595.html</a><br><a href="https://zhuanlan.zhihu.com/p/171787680">https://zhuanlan.zhihu.com/p/171787680</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>输入URL到构建全流程的经历</title>
    <url>//36/</url>
    <content><![CDATA[<h3 id="输入URL到构建全流程的经历"><a href="#输入URL到构建全流程的经历" class="headerlink" title="输入URL到构建全流程的经历"></a>输入URL到构建全流程的经历</h3><ol>
<li>在用户输入URL后，浏览器会自动检查地址完整性，补全漏写的协议等;</li>
<li>通过DNS把域名解析成服务器IP地址，得到地址后，客户端和服务端建立TCP连接，进行三次握手；</li>
<li>客户端会通过IP地址向服务端发送一个http请求，服务端在80端口接收到该请求后，返回HTTP报文给到浏览器;</li>
<li>浏览器解析报文内容，并继续搜索页面是否还有其它请求，有则继续通过IP地址向服务端发送http请求；</li>
<li>在接受到服务器返回的内容后，浏览器解析渲染页面；</li>
<li>所有请求都完成后，客户端和服务端断开连接，进行四次挥手。</li>
</ol>
<span id="more"></span>

<h4 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h4><p>构建 DOM 树、CSSOM、布局阶段、分层、绘制、分块、光栅化和合成</p>
<ol>
<li>渲染进程将HTML内容转换为浏览器可以理解的DOM树；渲染进程将CSS样式转化为CSSOM，计算出DOM节点样式。两者结合生成 render tree 渲染树。</li>
<li>创建布局树layout tree，计算布局信息</li>
<li>对布局树进行分层，生成分层树layer tree</li>
<li>每个图层生成绘制列表，并提交到合成线程</li>
<li>绘制列表是记录绘制指令的列表，比如每个元素的背景、边框都是一条单独的指令。</li>
<li>合成线程将图层分成图块，并在光栅化线程池中将图块转化为位图</li>
</ol>
<ul>
<li>图块：把整个浏览器分成小块，方便浏览器先加载可视区域</li>
<li>位图：即栅格图像，是由像素的单个点组成。这些点可以进行不同的排列和染色以构成图样。</li>
<li>这个过程会使用GPU加速</li>
</ul>
<ol start="7">
<li>合成线程发送绘制图块命令给浏览器进程。</li>
<li>浏览器进程根据命令生成页面，并显示到显示器上。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP缓存机制</title>
    <url>//37/</url>
    <content><![CDATA[<h3 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h3><ol>
<li>HTTP缓存机制：HTTP缓存即是浏览器第一次向一个服务器发起HTTP请求后，服务器会返回请求的资源，并且在响应头中添加一些有关缓存的字段如：cache-control，expires，last-modifed，ETag，Date等，之后浏览器再向该服务器请求资源就可以视情况使用强缓存和协商缓存。</li>
</ol>
<span id="more"></span>

<ol start="2">
<li>强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。</li>
<li>协商缓存：浏览器发送请求到服务器，服务器判断是否可使用本地缓存。</li>
</ol>
<p><img src="/37/37-1.png" alt="&#39;37-1&#39;"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS连接过程</title>
    <url>//38/</url>
    <content><![CDATA[<h3 id="HTTPS连接过程"><a href="#HTTPS连接过程" class="headerlink" title="HTTPS连接过程"></a>HTTPS连接过程</h3><p>HTTPS是在HTTP的基础上和ssl/tls证书结合起来的一种协议, 保证了传输过程中的安全性, 减少了被恶意劫持的可能. 很好的解决了解决了http的三个缺点（被监听、被篡改、被伪装）</p>
<span id="more"></span>

<h4 id="http通信存在的问题"><a href="#http通信存在的问题" class="headerlink" title="http通信存在的问题"></a>http通信存在的问题</h4><ol>
<li>容易被监听<br>http通信都是明文，数据在客户端与服务器通信过程中，任何一点都可能被劫持。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的</li>
<li>被伪装<br>http通信时，无法保证通行双方是合法的，通信方可能是伪装的。比如你请求<a href="http://www.taobao.com/">www.taobao.com</a>, 你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。</li>
<li>被篡改<br>hacker中间篡改数据后，接收方并不知道数据已经被更改</li>
</ol>
<h4 id="共享密钥加密和公开密钥加密"><a href="#共享密钥加密和公开密钥加密" class="headerlink" title="共享密钥加密和公开密钥加密"></a>共享密钥加密和公开密钥加密</h4><ol>
<li>共享密钥加密<br>共享密钥的加密密钥和解密密钥是相同的，所以又称为对称密钥</li>
<li>公开密钥加密<br>加密算法是公开的，密钥是保密的。公开密钥分为私有密钥和公有密钥，公有密钥是公开的，任何人(客户端)都可以获取，客户端使用公有密钥加密数据，服务端用私有密钥解密数据。</li>
<li>异同<br>共享密钥加密与公开密钥加密相比，加解密处理速度快，但公开密钥更适应互联网下使用</li>
</ol>
<h4 id="https解决的问题"><a href="#https解决的问题" class="headerlink" title="https解决的问题"></a>https解决的问题</h4><p>https很好的解决了http的三个缺点（被监听、被篡改、被伪装），https不是一种新的协议，它是http+SSL(TLS)的结合体，SSL是一种独立协议，所以其它协议比如smtp等也可以跟ssl结合。https改变了通信方式，它由以前的http—–&gt;tcp，改为http——&gt;SSL—–&gt;tcp；https采用了共享密钥加密+公开密钥加密的方式</p>
<ol>
<li>防监听<br>数据是加密的，所以监听得到的数据是密文，hacker看不懂。</li>
<li>防伪装<br>伪装分为客户端伪装和服务器伪装，通信双方携带证书，证书相当于身份证，有证书就认为合法，没有证书就认为非法，证书由第三方颁布，很难伪造</li>
<li>防篡改<br>https对数据做了摘要，篡改数据会被感知到。hacker即使从中改了数据也白搭。</li>
</ol>
<h4 id="https连接过程"><a href="#https连接过程" class="headerlink" title="https连接过程"></a>https连接过程</h4><p>服务器端需要认证的通信过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client-&gt;server: 发送客户端支持的加密协议及版本(SSL\TLS)</span><br><span class="line">server--&gt;client: 服务器端从中选择合适的加密协议</span><br><span class="line">server--&gt;client: 服务器端返回证书，证书中有公钥</span><br><span class="line">client-&gt;server: 客户端使用根证书验证证书合法性</span><br><span class="line">client-&gt;server: 客户端生成对称密钥，通过证书中的公钥加密，发送到服务器端</span><br><span class="line">server--&gt;client:服务器端使用私钥解密，获取对称密钥，使用对称密钥加密数据</span><br><span class="line">client-&gt;server: 客户端解密数据，SSL开始通信</span><br></pre></td></tr></table></figure>

<ol>
<li>客户端发送请求到服务器端</li>
<li>服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在</li>
<li>客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端</li>
<li>服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端</li>
<li>客户端使用共享密钥解密数据</li>
<li>SSL加密建立</li>
</ol>
<h4 id="客户端认证的通信的过程"><a href="#客户端认证的通信的过程" class="headerlink" title="客户端认证的通信的过程"></a>客户端认证的通信的过程</h4><p>客户端需要认证的过程跟服务器端需要认证的过程基本相同，并且少了最开始的两步。这种情况都是证书存储在客户端，并且应用场景比较少，一般金融才使用，比如支付宝、银行客户端都需要安装证书。</p>
<h4 id="后续的问题"><a href="#后续的问题" class="headerlink" title="后续的问题"></a>后续的问题</h4><ol>
<li>怎样保证公开密钥的有效性<br>你也许会想到，怎么保证客户端收到的公开密钥是合法的，不是伪造的，证书很好的完成了这个任务。证书由权威的第三方机构颁发，并且对公开密钥做了签名。</li>
<li>https的缺点<br>https保证了通信的安全，但带来了加密解密消耗计算机cpu资源的问题 ，不过，有专门的https加解密硬件服务器</li>
<li>各大互联网公司，百度、淘宝、支付宝、知乎都使用https协议，为什么？<br>支付宝涉及到金融，所以出于安全考虑采用https这个，可以理解，为什么百度、知乎等也采用这种方式？为了防止运营商劫持！http通信时，运营商在数据中插入各种广告，用户看到后，怒火发到互联网公司，其实这些坏事都是运营商(移动、联通、电信)干的, 用了https，运营商就没法插播广告篡改数据了。</li>
</ol>
<p>转发：<a href="https://blog.csdn.net/wangjun5159/article/details/51510594">https://blog.csdn.net/wangjun5159/article/details/51510594</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手、四次挥手、websocket连接</title>
    <url>//39/</url>
    <content><![CDATA[<h3 id="三次握手、四次挥手、websocket连接"><a href="#三次握手、四次挥手、websocket连接" class="headerlink" title="三次握手、四次挥手、websocket连接"></a>三次握手、四次挥手、websocket连接</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol>
<li>第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；</li>
</ol>
<span id="more"></span>

<ol start="2">
<li>第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；</li>
<li>第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。</li>
</ol>
<p><img src="/39/39-1.png" alt="&#39;39-1&#39;"></p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ol>
<li>第一次挥手：起初两端都处于ESTABLISHED状态，Client进程发出连接释放报文，并且停止发送数据。释放数据报文首部，Client将标志位FIN置为1，随机产生一个值seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），Client进入FIN-WAIT-1状态，等待server确认，TCP规定，FIN报文段即使不携带数据，也要消耗一个序号；</li>
<li>第二次挥手：Server收到连接释放报文后，发出确认报文，由标志位FIN=1得知client请求关闭连接，Server将标志位ACK置为1，ack=u+1，随机产生一个值seq=y，并将该确认报文发送给Client，Server进入CLOSE-WAIT状态。TCPServer通知高层的应用进程，Client向Server的方向就释放了，这时候处于半关闭状态，即Client已经没有数据要发送了，但是Server若发送数据，Client依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。Client收到Server的确认请求后，此时，Client就进入FIN-WAIT-2（终止等待2）状态，等待Server发送连接释放报文（在这之前还需要接受Server发送的最后的数据）；</li>
<li>第三次挥手：Server将最后的数据发送完毕后，就向Client发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，Server很可能又发送了一些数据，假定此时的序列号为seq=w，此时，Server就进入了LAST-ACK（最后确认）状态，等待Client的确认；</li>
<li>第四次挥手：Client收到Server的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，Client就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当Client撤销相应的TCB后，才进入CLOSED状态。Server只要收到了Client发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，Server结束TCP连接的时间要比Client早一些。</li>
</ol>
<p><img src="/39/39-2.png" alt="&#39;39-2&#39;"></p>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><ol>
<li>OSI 和TCP/IP 模型在传输层定义两种传输协议：TCP（或传输控制协议）和UDP（或用户数据报协议）。 </li>
<li>UDP 与TCP 的主要区别在于UDP 不一定提供可靠的数据传输。 事实上，该协议不能保证数据准确无误地到达目的地。</li>
</ol>
<h4 id="为什么TCP要进行四次挥手呢"><a href="#为什么TCP要进行四次挥手呢" class="headerlink" title="为什么TCP要进行四次挥手呢"></a>为什么TCP要进行四次挥手呢</h4><p>因为是双方彼此都建立了连接，因此双方都要释放自己的连接，A向B发出一个释放连接请求，他要释放链接表明不再向B发送数据了，此时B收到了A发送的释放链接请求之后，给A发送一个确认，A不能再向B发送数据了，它处于FIN-WAIT-2的状态，但是此时B还可以向A进行数据的传送。此时B向A 发送一个断开连接的请求，A收到之后给B发送一个确认。此时B关闭连接。A也关闭连接。</p>
<h4 id="为什么要有TIME-WAIT这个状态呢"><a href="#为什么要有TIME-WAIT这个状态呢" class="headerlink" title="为什么要有TIME-WAIT这个状态呢"></a>为什么要有TIME-WAIT这个状态呢</h4><p>这是因为有可能最后一次确认丢失，如果B此时继续向A发送一个我要断开连接的请求等待A发送确认，但此时A已经关闭连接了，那么B永远也关不掉了，所以我们要有TIME-WAIT这个状态。当然TCP也并不是100%可靠的。</p>
<h4 id="time-wait的作用，还有它的开始时间"><a href="#time-wait的作用，还有它的开始时间" class="headerlink" title="time-wait的作用，还有它的开始时间"></a>time-wait的作用，还有它的开始时间</h4><p>time-wait开始的时间为tcp四次挥手中主动关闭连接方发送完最后一次挥手，也就是ACK=1的信号结束后，主动关闭连接方所处的状态。然后time-wait的的持续时间为2MSL. MSL是Maximum Segment Lifetime, 译为“报文最大生存时间”，可为30s，1min或2min。2msl就是2倍的这个时间。工程上为2min，2msl就是4min。但一般根据实际的网络情况进行确定。</p>
<h4 id="为什么要持续这么长的时间呢"><a href="#为什么要持续这么长的时间呢" class="headerlink" title="为什么要持续这么长的时间呢"></a>为什么要持续这么长的时间呢</h4><ol>
<li>为了保证客户端发送的最后一个ack报文段能够到达服务器。因为这最后一个ack确认包可能会丢失，然后服务器就会超时重传第三次挥手的fin信息报，然后客户端再重传一次第四次挥手的ack报文。如果没有这2msl，客户端发送完最后一个ack数据报后直接关闭连接，那么就接收不到服务器超时重传的fin信息报(此处应该是客户端收到一个非法的报文段，而返回一个RST的数据报，表明拒绝此次通信，然后双方就产生异常，而不是收不到。)，那么服务器就不能按正常步骤进入close状态。那么就会耗费服务器的资源。当网络中存在大量的timewait状态，那么服务器的压力可想而知。</li>
<li>在第四次挥手后，经过2msl的时间足以让本次连接产生的所有报文段都从网络中消失，这样下一次新的连接中就肯定不会出现旧连接的报文段了。</li>
</ol>
<h4 id="为什么不能用两次握手进行连接？"><a href="#为什么不能用两次握手进行连接？" class="headerlink" title="为什么不能用两次握手进行连接？"></a>为什么不能用两次握手进行连接？</h4><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<h4 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><ol>
<li>WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</li>
<li>为什么传统的HTTP协议不能做到WebSocket实现的功能？这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。</li>
<li>也有人说，HTTP协议其实也能实现啊，比如用轮询或者Comet。轮询是指浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息。这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。</li>
<li>Comet本质上也是轮询，但是在没有消息的情况下，服务器先拖一段时间，等到有消息了再回复。这个机制暂时地解决了实时性问题，但是它带来了新的问题：以多线程模式运行的服务器会让大部分线程大部分时间都处于挂起状态，极大地浪费服务器资源。另外，一个HTTP连接在长时间没有数据传输的情况下，链路上的任何一个网关都可能关闭这个连接，而网关是我们不可控的，这就要求Comet连接必须定期发一些ping数据表示连接“正常工作”。</li>
<li>以上两种机制都治标不治本，所以，HTML5推出了WebSocket标准，让浏览器和服务器之间可以建立无限制的全双工通信，任何一方都可以主动发消息给对方。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>async函数原理及使用方法</title>
    <url>//4/</url>
    <content><![CDATA[<h3 id="async函数原理及使用方法"><a href="#async函数原理及使用方法" class="headerlink" title="async函数原理及使用方法"></a>async函数原理及使用方法</h3><blockquote>
<p>async 函数是 Generator 函数的语法糖，async 函数的实现原理，就是将 <a href="/5/" title="Generator函数">Generator函数</a>和自动执行器，包装在一个函数里。</p>
</blockquote>
<span id="more"></span>

<h4 id="1-Generator-函数"><a href="#1-Generator-函数" class="headerlink" title="1. Generator 函数"></a>1. Generator 函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成async是：</span></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await。</p>
<h4 id="2-async具体使用和优点"><a href="#2-async具体使用和优点" class="headerlink" title="2.async具体使用和优点"></a>2.async具体使用和优点</h4><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeout(ms);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码指定 50 毫秒以后，输出hello world。</p>
<p>async异步函数变体：</p>
<blockquote>
<p>异步函数声明： async function foo() {}</p>
</blockquote>
<p>异步函数表达式： const foo = async function () {};<br>异步函数定义：let obj = { async foo() {} }<br>异步箭头函数： const foo = async () =&gt; {}; </p>
<blockquote>
</blockquote>
<p>理解：<br>1.async 表示这是一个 async 函数，而 await 只能在这个函数里面使用。<br>2.await 表示在这里等待 await 后面的操作执行完毕，再执行下一句代码。<br>3.await 后面紧跟着的最好是一个耗时的操作或者是一个异步操作(当然非耗时的操作也可以的，但是就失去意义了)。</p>
<h4 id="3-错误处理"><a href="#3-错误处理" class="headerlink" title="3. 错误处理"></a>3. 错误处理</h4><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">    .then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure>

<p>防止出错的方法，也是将其放在try…catch代码块之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val1 = <span class="keyword">await</span> firstStep();</span><br><span class="line">        <span class="keyword">const</span> val2 = <span class="keyword">await</span> secondStep(val1);</span><br><span class="line">        <span class="keyword">const</span> val3 = <span class="keyword">await</span> thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Final: &#x27;</span>, val3);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async是一个Promis对象，我们可以在async后面加上then或者catch这个东西来防止出错。</p>
<p>转：<a href="https://www.cnblogs.com/luozhixiang/p/9116965.html">https://www.cnblogs.com/luozhixiang/p/9116965.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP与UDP区别及相关特性</title>
    <url>//40/</url>
    <content><![CDATA[<h3 id="TCP与UDP区别及相关特性"><a href="#TCP与UDP区别及相关特性" class="headerlink" title="TCP与UDP区别及相关特性"></a>TCP与UDP区别及相关特性</h3><h4 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h4><p>包(Packet)是TCP/IP协议通信传输中的数据单位，一般也称“数据包”。包在包交换网络里，单个消息被划分为多个数据块，这些数据块称为包，它包含发送者和接收者的地址信息。这些包然后沿着不同的路径在一个或多个网络中传输，并且在目的地重新组合。数据包主要由“目的IP地址”、“源IP地址”、“净载数据”等部分构成，包括包头和包体，包头是固定长度，包体的长度不定，各字段长度固定，双方的请求数据包和应答数据包的包头结构是一致的，不同的是包体的定义。数据包的结构与我们平常写信非常类似，目的IP地址是说明这个数据包是要发给谁的，相当于收信人地址；源IP地址是说明这个数据包是发自哪里的，相当于发信人地址；而净载数据相当于信件的内容。正是因为数据包具有这样的结构，安装了TCP/IP协议的计算机之间才能相互通信。我们在使用基于TCP/IP协议的网络时，网络中其实传递的就是数据包</p>
<span id="more"></span>

<h4 id="TCP特性"><a href="#TCP特性" class="headerlink" title="TCP特性"></a>TCP特性</h4><ol>
<li>面向连接<br>“面向连接”就是在正式通信前必须要与对方建立起连接。比如你给别人打电话，必须等线路接通了、对方拿起话筒才能相互通话。TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。    </li>
<li>三次会话<br>一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。我们来看看这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。    </li>
<li>通信效率低、可靠性高    <br>TCP协议能为应用程序提供可靠的通信连接，使一台计算机发出的字节流无差错地发往网络上的其他计算机，对可靠性要求高的数据通信系统往往使用TCP协议传输数据。</li>
</ol>
<h4 id="3、UDP特性"><a href="#3、UDP特性" class="headerlink" title="3、UDP特性"></a>3、UDP特性</h4><ol>
<li>面向非连接     <br>“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。这与现在风行的手机短信非常相似：你在发短信的时候，只需要输入对方手机号就OK了。     <br>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！     </li>
<li>通信效率高、可靠性低     <br>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包（如图所示）。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效率高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。     </li>
</ol>
<h4 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h4><ol>
<li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li>
<li>TCP提供可靠的服务。UDP尽最大努力交付，即不保证可靠交付。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达，TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答等机制实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li>
<li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li>
<li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li>
<li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域</title>
    <url>//42/</url>
    <content><![CDATA[<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>指一个域下的文档或脚本试图去请求另一个域下的资源。</p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ol>
<li>资源跳转： a链接、重定向、表单提交</li>
<li>资源嵌入：<link>、<script>、<img>、<frame>等dom标签，还有样式中background:url()、@font-face()等文件</li>
<li>外链脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</li>
</ol>
<blockquote>
<p>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。</p>
</blockquote>
<p>同源是指”协议+域名+端口”三者相同且必须相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>一个域名地址的组成：<br>http://  www  .  abc.com  :  8080  /  scripts/jquery.js<br> 协议   子域名     主域名      端口号      请求资源地址</p>
<p>同源策略<br>限制：cookie, localStorage, sessionStorage, indexDB, ajax请求, DOM操作、js操作, iconfont字体文件{eot|otf|ttf|woff|svg}, canvas绘制的图片资源<br>不限制: 请求静态资源css、js、图片</p>
<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><h5 id="通过jsonp跨域-–不推荐"><a href="#通过jsonp跨域-–不推荐" class="headerlink" title="通过jsonp跨域 –不推荐"></a>通过jsonp跨域 –不推荐</h5><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。但只能实现get一种请求。</p>
<h5 id="document-domain-iframe跨域-–不推荐"><a href="#document-domain-iframe跨域-–不推荐" class="headerlink" title="document.domain + iframe跨域 –不推荐"></a>document.domain + iframe跨域 –不推荐</h5><p>两个页面都通过js强制设置document.domain为基础主域，就实现了同域。因此此方案仅限主域相同，子域不同的跨域应用场景。</p>
<h5 id="location-hash-iframe跨域-–不推荐"><a href="#location-hash-iframe跨域-–不推荐" class="headerlink" title="location.hash + iframe跨域 –不推荐"></a>location.hash + iframe跨域 –不推荐</h5><ol>
<li>a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</li>
<li>在url： <a href="http://a.com/#helloword%E4%B8%AD%E7%9A%84%E2%80%98#helloworld%E2%80%99">http://a.com#helloword中的‘#helloworld’</a> 就是 location.hash</li>
<li>实现方式：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</li>
</ol>
<h5 id="window-name-iframe跨域-–不推荐"><a href="#window-name-iframe跨域-–不推荐" class="headerlink" title="window.name + iframe跨域 –不推荐"></a>window.name + iframe跨域 –不推荐</h5><p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h5 id="postMessage跨域-–不推荐"><a href="#postMessage跨域-–不推荐" class="headerlink" title="postMessage跨域 –不推荐"></a>postMessage跨域 –不推荐</h5><ol>
<li>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，他可以解决这类问题：页面和其打开的新窗口的数据传递；多窗口之间消息传递；页面与嵌套的iframe消息传递。</li>
<li>使用方法：postMessage(data,origin)方法接受两个参数</li>
</ol>
<ul>
<li>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>
<li>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li>
</ul>
<p>请求页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            name: <span class="string">&#x27;aym&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;; <span class="comment">// 向domain2传送跨域数据 </span></span></span><br><span class="line"><span class="javascript">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain2.com&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;; <span class="comment">// 接受domain2返回数据 </span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.data);</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接收页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接收domain1的数据    </span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.data);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span></span><br><span class="line">        if (data) &#123;</span><br><span class="line"><span class="javascript">            data.number = <span class="number">16</span>; <span class="comment">// 处理后再发回domain1                  </span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain1.com&#x27;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="CORS（跨域资源共享：Cross-Origin-Resource-Sharing）–不推荐"><a href="#CORS（跨域资源共享：Cross-Origin-Resource-Sharing）–不推荐" class="headerlink" title="CORS（跨域资源共享：Cross-Origin Resource Sharing）–不推荐"></a>CORS（跨域资源共享：Cross-Origin Resource Sharing）–不推荐</h5><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。需注意的是：由于同源策略的限制，所读取的cookie为跨域所在域的cookie，而非当前页。</p>
<h5 id="nginx代理"><a href="#nginx代理" class="headerlink" title="nginx代理"></a>nginx代理</h5><ol>
<li>iconfont跨域：浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</li>
<li>接口跨域：同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</li>
<li>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录</li>
</ol>
<h5 id="Nodejs中间件代理跨域"><a href="#Nodejs中间件代理跨域" class="headerlink" title="Nodejs中间件代理跨域"></a>Nodejs中间件代理跨域</h5><ol>
<li>原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 </li>
<li>实现方式分为两类：是否运用webpack    </li>
</ol>
<ul>
<li>不使用webpack：两次跨域，利用node + express + http-proxy-middleware搭建一个proxy服务器。</li>
<li>运用webpack：利用node + webpack + webpack-dev-server代理接口跨域。（此方法与Nginx代理跨域原理基本一致，因此建议使用Nginx代理即可。）</li>
</ul>
</script></li></ol>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP建立后包含多少HTTP，以及相关衍生的概念</title>
    <url>//41/</url>
    <content><![CDATA[<h3 id="TCP建立后包含多少HTTP，以及相关衍生的概念"><a href="#TCP建立后包含多少HTTP，以及相关衍生的概念" class="headerlink" title="TCP建立后包含多少HTTP，以及相关衍生的概念"></a>TCP建立后包含多少HTTP，以及相关衍生的概念</h3><p>一道经典的面试题是从 URL 在浏览器被被输入到页面展现的过程中发生了什么，大多数回答都是说请求响应之后 DOM 怎么被构建，被绘制出来。</p>
<p>但是你有没有想过，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？<br>要搞懂这个问题，我们需要先解决下面五个问题：<br>现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</p>
<p>一个 TCP 连接可以对应几个 HTTP 请求？</p>
<p>一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？</p>
<p>为什么有的时候刷新页面不需要重新建立 SSL 连接？</p>
<p>浏览器对同一 Host 建立 TCP 连接到数量有没有限制？</p>
<span id="more"></span>

<p>先来谈谈第一个问题：现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？<br>在 HTTP/1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。<br>意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免，两张图片是我短时间内两次访问 github.com 的时间统计：</p>
<p><img src="/41/41-1.png"></p>
<p>头一次访问，有初始化连接和 SSL 开销</p>
<p><img src="/41/41-2.png"></p>
<p>初始化连接和 SSL 开销消失了，说明使用的是同一个 TCP 连接</p>
<p>持久连接：既然维持 TCP 连接好处这么多，HTTP/1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。<br>所以第一个问题的答案是：默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。<br>第二个问题：一个 TCP 连接可以对应几个 HTTP 请求？<br>了解了第一个问题之后，其实这个问题已经有了答案，如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。<br>第三个问题：一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？<br>HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。<br>虽然 HTTP/1.1 规范中规定了 Pipelining 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。<br>先来看一下 Pipelining 是什么，RFC 2616 中规定了：<br>A client that supports persistent connections MAY “pipeline” its requests (i.e., send multiple requests without waiting for each response). A server MUST send its responses to those requests in the same order that the requests were received.</p>
<p>一个支持持久连接的客户端可以在一个连接中发送多个请求（不需要等待任意请求的响应）。收到请求的服务器必须按照请求收到的顺序发送响应。<br>至于标准为什么这么设定，我们可以大概推测一个原因：由于 HTTP/1.1 是个文本协议，同时返回的内容也并不能区分对应于哪个发送的请求，所以顺序必须维持一致。</p>
<p>比如你向服务器发送了两个请求 GET /query?q=A 和 GET /query?q=B，服务器返回了两个结果，浏览器是没有办法根据响应结果来判断响应对应于哪一个请求的。</p>
<p>Pipelining 这种设想看起来比较美好，但是在实践中会出现许多问题：</p>
<ol>
<li>一些代理服务器不能正确的处理 HTTP Pipelining。</li>
<li>正确的流水线实现是复杂的。</li>
<li>Head-of-line Blocking 连接头阻塞：在建立起一个 TCP 连接之后，假设客户端在这个连接连续向服务器发送了几个请求。按照标准，服务器应该按照收到请求的顺序返回结果，假设服务器在处理首个请求时花费了大量时间，那么后面所有的请求都需要等着首个请求结束才能响应。</li>
</ol>
<p>所以现代浏览器默认是不开启 HTTP Pipelining 的。<br>但是，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求。至于 Multiplexing 具体怎么实现的就是另一个问题了。我们可以看一下使用 HTTP2 的效果。</p>
<p><img src="/41/41-3.png"></p>
<p>绿色是发起请求到请求返回的等待时间，蓝色是响应的下载时间，可以看到都是在同一个 Connection，并行完成的。<br>所以这个问题也有了答案：在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。<br>那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：<br>维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。</p>
<p>和服务器建立多个 TCP 连接。</p>
<p>第四个问题：为什么有的时候刷新页面不需要重新建立 SSL 连接？<br>在第一个问题的讨论中已经有答案了，TCP 连接有的时候会被浏览器和服务端维持一段时间。TCP 不需要重新建立，SSL 自然也会用之前的。<br>第五个问题：浏览器对同一 Host 建立 TCP 连接到数量有没有限制？<br>假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？</p>
<p>肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。<br>所以答案是：有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。<br>那么回到最开始的问题，收到的 HTML 如果包含几十个图片标签，这些图片是以什么方式、什么顺序、建立了多少连接、使用什么协议被下载下来的呢？<br>如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。<br>如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。</p>
<p>那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。</p>
<p>转发：<a href="https://www.cnblogs.com/java-stack/p/11952097.html">https://www.cnblogs.com/java-stack/p/11952097.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS、CSRF安全</title>
    <url>//43/</url>
    <content><![CDATA[<h3 id="XSS、CSRF安全"><a href="#XSS、CSRF安全" class="headerlink" title="XSS、CSRF安全"></a>XSS、CSRF安全</h3><p>web端的安全攻击有CSRF和XSS两种。</p>
<h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>CSRF（Cross-site request forgery）跨站请求伪造，是通过伪装成受信任用户的请求来利用受信任的网站进行攻击。</p>
<span id="more"></span>

<h5 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h5><p><img src="/43/43-1.jpg"></p>
<h5 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h5><ol>
<li>CSRF是攻击者可以利用保存到cookie伪造用户发送请求，所以防御的关键是在请求中放入攻击者不可伪造的信息。</li>
<li>Token验证：在http请求的头信息中增加一个Token字段，并在服务器端判断是否Token一致，通过校验携带的Token信息决定是否允许请求。</li>
<li>Referer验证：在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。如果Referer是可信任的网站来源，则允许，否则拒绝。（例如用户在登录某银行网站A.com后点击转账按钮发送转账请求，此时该请求的头信息的Referer就是有转账按钮的URL，服务器判断是否为银行网站的URL，是的话请求就合法，不是的话就可能是CSRF攻击，则拒绝请求。）</li>
</ol>
<h4 id="CSRF安全"><a href="#CSRF安全" class="headerlink" title="CSRF安全"></a>CSRF安全</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>XSS攻击全称跨站脚本攻击，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。</p>
<h5 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h5><p><img src="/43/43-1.jpg"></p>
<h5 id="防御措施-1"><a href="#防御措施-1" class="headerlink" title="防御措施"></a>防御措施</h5><ol>
<li>过滤：表单提交或者url参数传递前，对需要的参数进行过滤</li>
<li>转化：有时不能对数据进行严格的过滤，那我们也需要对标签进行转换,例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如用户输入：&lt;script&gt;alert(&quot;222&quot;)&lt;&#x2F;script&gt;，保存后最终存储的会是&lt;script&gt;alert&#x3D;&quot;222;&lt;&#x2F;script&gt;在展现时浏览器会对这些字符转换成文本内容显示，而不是一段可执行的代码。</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS垃圾回收</title>
    <url>//44/</url>
    <content><![CDATA[<h3 id="JS垃圾回收"><a href="#JS垃圾回收" class="headerlink" title="JS垃圾回收"></a>JS垃圾回收</h3><p>JS的垃圾回收机制是为了以防内存泄漏。</p>
<h4 id="内存泄漏："><a href="#内存泄漏：" class="headerlink" title="内存泄漏："></a>内存泄漏：</h4><p>就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。</p>
<h4 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h4><p>当一个变量的生命周期结束之后它所指向的内存就应该被释放。JS有两种变量，全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。</p>
<h4 id="JS垃圾回收方式"><a href="#JS垃圾回收方式" class="headerlink" title="JS垃圾回收方式"></a>JS垃圾回收方式</h4><h5 id="标记清除（mark-and-sweep）"><a href="#标记清除（mark-and-sweep）" class="headerlink" title="标记清除（mark and sweep）"></a>标记清除（mark and sweep）</h5><p>大部分浏览器以此方式进行垃圾回收，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。标记方式不定，可以是某个特殊位的反转或维护一个列表等。</p>
<h5 id="引用计数-reference-counting"><a href="#引用计数-reference-counting" class="headerlink" title="引用计数(reference counting)"></a>引用计数(reference counting)</h5><p>这种方式常常会引起内存泄漏，低版本的IE使用这种方式。机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。</p>
<h5 id="“可达性”-值"><a href="#“可达性”-值" class="headerlink" title="“可达性” 值"></a>“可达性” 值</h5><p>就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。</p>
<p>深入了解：<a href="https://www.cnblogs.com/huaweiyun/p/14435787.html">https://www.cnblogs.com/huaweiyun/p/14435787.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包</title>
    <url>//45/</url>
    <content><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>使用闭包主要是为了设计私有的方法和变量</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>可以避免全局变量的污染</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。</li>
<li>在Javascript中，函数即闭包，只有函数才会产生作用域。</li>
</ol>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>函数嵌套函数</li>
<li>在函数内部可以引用外部的参数和变量</li>
<li>参数和变量不会以垃圾回收机制回收</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>原型链</title>
    <url>//46/</url>
    <content><![CDATA[<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ol>
<li>JavaScript并非通过类而是直接通过构造函数来创建实例 </li>
<li>构造函数</li>
</ol>
<ul>
<li>构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立的，即实例识别。</li>
<li>构造函数习惯上首字母大写，需要使用new关键字来调用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.gender = gender</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(per); <span class="comment">//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ul>
<li>每创建一个Person构造函数，在Person构造函数中，为每一个对象都添加了一个sayName方法，也就是说构造函数每执行一次就会创建一个新的sayName方法。为什么不把这个方法单独放到一个地方，并让所有的实例都可以访问到呢? 这就需要原型(prototype)</li>
</ul>
<ol start="3">
<li>原型</li>
</ol>
<ul>
<li>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。</li>
</ul>
<p><img src="/46/46-1.png"></p>
<ul>
<li>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。</li>
</ul>
<ol start="4">
<li>原型链</li>
</ol>
<ul>
<li>每个对象数据类型（普通的对象、实例、prototype）也天生自带一个属性__proto__，属性值是当前实例所属类的原型（prototype）。原型对象中有一个属性constructor，它指向函数对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person) <span class="comment">//true</span></span><br><span class="line"><span class="comment">//获取对象原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><img src="/46/46-2.png"></p>
<ol start="5">
<li><p>在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</p>
</li>
<li><p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。</p>
</li>
</ol>
<ul>
<li>我们可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性；使用in检查对象中是否含有某个属性时，如果对象没有但是原型中有，也会返回true</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.a = <span class="number">123</span>;</span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.a) <span class="comment">//123</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> person) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层Object为止。Object是JS中所有对象数据类型的基类(最顶层的类)在Object.prototype上没有__proto__这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="/46/46-3.png"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>//47/</url>
    <content><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>类的继承：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    f.prototype = parent.prototype;</span><br><span class="line">    child.prototype = <span class="keyword">new</span> f();</span><br><span class="line">    child.prototype.constructor = child;</span><br><span class="line">&#125; <span class="comment">//这是一个封装函数,再进行类的继承时,可以用这个函数来套用</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>中间函数完成原型链继承。Object.keys 只收集自身属性名，不继承自原型链上的属性</p>
<p>获取一个对象的原型，在chrome中可以通过_proto_的形式，或者在ES6中可以通过Object.getPrototypeOf的形式。<br>那么Function.proto是什么么？也就是说Function由什么对象继承而来，我们来做如下判别。<br>Function.<strong>proto</strong>==Object.prototype //falseFunction.<strong>proto</strong>==Function.prototype//true<br>我们发现Function的原型也是Function。</p>
<p>我们用图可以来明确这个关系：</p>
<p><img src="/47/47-1.png" alt="47-1.png"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器进程，线程</title>
    <url>//48/</url>
    <content><![CDATA[<h3 id="进程（process）和线程（thread）"><a href="#进程（process）和线程（thread）" class="headerlink" title="进程（process）和线程（thread）"></a>进程（process）和线程（thread）</h3><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><p>CPU是计算机的核心，其负责承担计算机的计算任务。这里我们比喻为一个工厂</p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。我们这里将进程比喻为工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元。这里把线程比喻一个车间的工人，即一个车间可以允许由多个工人协同完成一个任务。</p>
<span id="more"></span>

<h4 id="进程和线程的区别和关系"><a href="#进程和线程的区别和关系" class="headerlink" title="进程和线程的区别和关系"></a>进程和线程的区别和关系</h4><ol>
<li>进程是操作系统分配资源的最小单位，线程是程序执行的最小单位。</li>
<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>
<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。</li>
<li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li>
</ol>
<h3 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h3><ol>
<li>多进程：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li>
<li>多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li>
</ol>
<h4 id="浏览器多进程架构"><a href="#浏览器多进程架构" class="headerlink" title="浏览器多进程架构"></a>浏览器多进程架构</h4><p>跟现在的很多多线程浏览器不一样，Chrome浏览器使用多个进程来隔离不同的网页。因此在Chrome中打开一个网页相当于起了一个进程。</p>
<p>那么Chrome为什么要使用多进程架构?</p>
<p>在浏览器刚被设计出来的时候，那时的网页非常的简单，每个网页的资源占有率是非常低的，因此一个进程处理多个网页时可行的。然后在今天，大量网页变得日益复杂。把所有网页都放进一个进程的浏览器面临在健壮性，响应速度，安全性方面的挑战。因为如果浏览器中的一个tab网页崩溃的话，将会导致其他被打开的网页应用。另外相对于线程，进程之间是不共享资源和地址空间的, 所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源, 所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。</p>
<p>在了解这个知识点线，我们需要先说明下什么是浏览器内核。</p>
<h4 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h4><p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。从上面我们可以知道，Chrome浏览器为每个tab页面单独启用进程，因此每个tab网页都有由其独立的渲染引擎实例。</p>
<h4 id="浏览器内核是多线程"><a href="#浏览器内核是多线程" class="headerlink" title="浏览器内核是多线程"></a>浏览器内核是多线程</h4><p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p>
<ol>
<li>GUI 渲染线程</li>
<li>JavaScript引擎线程</li>
<li>定时触发器线程</li>
<li>事件触发线程</li>
<li>异步http请求线程</li>
</ol>
<h4 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a>GUI渲染线程</h4><p>GUI渲染线程负责渲染浏览器界面HTML元素, 当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时, 该线程就会执行。在Javascript引擎运行脚本期间, GUI渲染线程都是处于挂起状态的, 也就是说被”冻结”了.</p>
<h4 id="Javascript引擎线程"><a href="#Javascript引擎线程" class="headerlink" title="Javascript引擎线程"></a>Javascript引擎线程</h4><p>Javascript引擎，也可以称为JS内核，主要负责处理Javascript脚本程序，例如V8引擎。Javascript引擎线程理所当然是负责解析Javascript脚本，运行代码。</p>
<h4 id="Javascript是单线程的"><a href="#Javascript是单线程的" class="headerlink" title="Javascript是单线程的"></a>Javascript是单线程的</h4><p>Javascript是单线程的, 那么为什么Javascript要是单线程的？</p>
<p>这是因为Javascript这门脚本语言诞生的使命所致：JavaScript为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突； 如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。</p>
<h4 id="GUI-渲染线程-与-JavaScript引擎线程互斥！"><a href="#GUI-渲染线程-与-JavaScript引擎线程互斥！" class="headerlink" title="GUI 渲染线程 与 JavaScript引擎线程互斥！"></a>GUI 渲染线程 与 JavaScript引擎线程互斥！</h4><p>从上面我们可以推理出，由于GUI渲染线程与JavaScript执行线程是互斥的关系，当浏览器在执行JavaScript程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p>
<h4 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h4><p>浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</p>
<h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p>
<h4 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步http请求线程</h4><p>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。</p>
<p>转发：<a href="https://www.cnblogs.com/passkey/p/10183188.html">https://www.cnblogs.com/passkey/p/10183188.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS设计模式</title>
    <url>//49/</url>
    <content><![CDATA[<h3 id="JS设计模式"><a href="#JS设计模式" class="headerlink" title="JS设计模式"></a>JS设计模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>思想：保证一个类只有一个实例，并提供一个访问它的全局访问点。实现方法：先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>转发：<a href="https://cuggz.blog.csdn.net/article/details/108332671">https://cuggz.blog.csdn.net/article/details/108332671</a><br>转发：<a href="https://blog.csdn.net/qq_42033567/article/details/108438588">https://blog.csdn.net/qq_42033567/article/details/108438588</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Generator 函数</title>
    <url>//5/</url>
    <content><![CDATA[<h3 id="ES6-Generator-函数"><a href="#ES6-Generator-函数" class="headerlink" title="ES6 Generator 函数"></a>ES6 Generator 函数</h3><p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p>
<h4 id="Generator-函数组成"><a href="#Generator-函数组成" class="headerlink" title="Generator 函数组成"></a>Generator 函数组成</h4><p>Generator 有两个区分于普通函数的部分：</p>
<ol>
<li>在 function 后面，函数名之前有个 * ；</li>
<li>函数内部有 yield 表达式。</li>
</ol>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h4><p>调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f.next();</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one , 执行到 yield 就停下来，并将yield 后边表达式的值 ‘1’，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。</p>
<p>第二次调用 next 方法时，同上步 。</p>
<p>第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。</p>
<p>第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。</p>
<h4 id="函数返回的遍历器对象的方法"><a href="#函数返回的遍历器对象的方法" class="headerlink" title="函数返回的遍历器对象的方法"></a>函数返回的遍历器对象的方法</h4><h5 id="next-方法"><a href="#next-方法" class="headerlink" title="next 方法"></a>next 方法</h5><p>一般情况下，next 方法不传入参数的时候，yield 表达式的返回值是 undefined 。当 next 传入参数的时候，该参数会作为上一步yield的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sendParameter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;one:&quot;</span> + x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;two:&quot;</span> + y);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;total:&quot;</span> + (x + y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//next不传参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendp1 = sendParameter();</span><br><span class="line">sendp1.next();</span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">sendp1.next();</span><br><span class="line"><span class="comment">// one:undefined</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: false&#125;</span></span><br><span class="line">sendp1.next();</span><br><span class="line"><span class="comment">// two:undefined</span></span><br><span class="line"><span class="comment">// total:NaN</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//next传参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendp2 = sendParameter();</span><br><span class="line">sendp2.next(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">sendp2.next(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// one:20</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: false&#125;</span></span><br><span class="line">sendp2.next(<span class="number">30</span>);</span><br><span class="line"><span class="comment">// two:30</span></span><br><span class="line"><span class="comment">// total:50</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>除了使用 next ，还可以使用 for… of 循环遍历 Generator 函数生产的 Iterator 对象。</p>
<h5 id="return-方法"><a href="#return-方法" class="headerlink" title="return 方法"></a>return 方法</h5><p>return 方法返回给定值，并结束遍历 Generator 函数。</p>
<p>return 方法提供参数时，返回该参数；不提供参数时，返回 undefined 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.return(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;value: &quot;foo&quot;, done: true&#125;</span></span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="keyword">throw</span> 方法</span><br><span class="line"><span class="keyword">throw</span> 方法可以再 Generator 函数体外面抛出异常， 再函数体内部捕获。</span><br><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;catch inner&#x27;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    i.throw(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    i.throw(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch outside&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// catch inner a</span></span><br><span class="line"><span class="comment">// catch outside b</span></span><br></pre></td></tr></table></figure>

<p>遍历器对象抛出了两个错误，第一个被 Generator 函数内部捕获，第二个因为函数体内部的catch 函数已经执行过了，不会再捕获这个错误，所以这个错误就抛出 Generator 函数体，被函数体外的 catch 捕获。</p>
<h4 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h4><p>yield* 表达式表示 yield 返回一个遍历器对象，用于在 Generator 函数内部，调用另一个 Generator 函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">callee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;callee: &#x27;</span> + (<span class="keyword">yield</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">caller</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span>* callee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> callerObj = caller();</span><br><span class="line">callerObj.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">callerObj.next(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">// callee: a</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">callerObj.next(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// callee: b</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">caller</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> callee) &#123;</span><br><span class="line">            <span class="keyword">yield</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><h5 id="实现-Iterator"><a href="#实现-Iterator" class="headerlink" title="实现 Iterator"></a>实现 Iterator</h5><p>为不具备 Iterator 接口的对象提供遍历方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> propKeys = <span class="built_in">Reflect</span>.ownKeys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">        <span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = &#123;</span><br><span class="line">    first: <span class="string">&#x27;Jane&#x27;</span>,</span><br><span class="line">    last: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> objectEntries(jane)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure>

<p>Reflect.ownKeys() 返回对象所有的属性，不管属性是否可枚举，包括 Symbol。</p>
<p>jane 原生是不具备 Iterator 接口无法通过 for… of遍历。这边用了 Generator 函数加上了 Iterator 接口，所以就可以遍历 jane 对象了。</p>
<p>转：<a href="https://www.runoob.com/w3cnote/es6-generator.html">https://www.runoob.com/w3cnote/es6-generator.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>this指向</title>
    <url>//50/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS模块化</title>
    <url>//51/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeShaking</title>
    <url>//52/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>JS拷贝相关</title>
    <url>//53/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack如何进行前端优化</title>
    <url>//54/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-diff算法</title>
    <url>//55/</url>
    <content><![CDATA[<h3 id="Vue-diff算法"><a href="#Vue-diff算法" class="headerlink" title="Vue-diff算法"></a>Vue-diff算法</h3><h4 id="为什么要用Diff算法"><a href="#为什么要用Diff算法" class="headerlink" title="为什么要用Diff算法"></a>为什么要用Diff算法</h4><p>在浏览器中操作DOM的代价是非常“昂贵”的。。。</p>
<h4 id="传统的Diff算法"><a href="#传统的Diff算法" class="headerlink" title="传统的Diff算法"></a>传统的Diff算法</h4><p>传统的Diff算法通过循环递归对节点进行比较，然后判断每个节点的状态以及要做的操作（add，remove，change），最后根据Virtual DOM进行DOM的渲染。大体流程如下图:</p>
<p><img src="/55/55-1.png"></p>
<p>传统Diff算法的复杂度为O(n^3)，这个复杂度相对来说还是较高的。后来React开发者提供了一种复杂度仅为O(n)的Diff算法。下面就来看一下O(n)复杂度的Diff算法是如何实现的。</p>
<h4 id="更高效的Diff算法"><a href="#更高效的Diff算法" class="headerlink" title="更高效的Diff算法"></a>更高效的Diff算法</h4><p>React的开发者结合Web界面的特点做出了两个大胆的假设，使得Diff算法复杂度直接从O(n^3)降低到O(n)，假设如下：</p>
<ul>
<li>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；</li>
<li>对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</li>
</ul>
<span id="more"></span>

<p>通过这两个假设，他们提供了下面的Diff算法思路。</p>
<p>同层比较</p>
<p>新的Diff算法是逐层进行比较，只比较同一层次的节点，大大降低了复杂度，具体如下图。在后面的内容中也会介绍Vue中同层节点比较的具体实现。</p>
<p><img src="/55/55-2.png"></p>
<p>不同类型节点的比较<br>如果发现新旧两个节点类型不同时，Diff算法会直接删除旧的节点及其子节点并插入新的节点，这是由于前面提出的不同组件产生的DOM结构一般是不同的，所以可以不用浪费时间去比较。注意的是，删除节点意味着彻底销毁该节点，并不会将该节点去与后面的节点相比较。</p>
<p>相同类型节点的比较<br>若是两个节点类型相同时，Diff算法会更新节点的属性实现转换。</p>
<p>列表节点的比较<br>列表节点的操作一般包括添加、删除和排序，列表节点需要我们给它一个key才能进行高效的比较。</p>
<h4 id="Vue-Diff算法的实现"><a href="#Vue-Diff算法的实现" class="headerlink" title="Vue Diff算法的实现"></a>Vue Diff算法的实现</h4><p>Vue的Diff算法与上面的思路大体相似，只比较同级的节点，若找不到与新节点类型相同的节点，则插入一个新节点，若有相同类型的节点则进行节点属性的更新，最后删除新节点列表中不包含的旧节点。具体的实现在vue源码的src/core/vdom/patch.js中的updateChildren方法中，由于代码较长，下面简单说一下整个的比较流程。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p><img src="/55/55-3.png"></p>
<p>如上图，有一组新旧节点数组before：[A, B, C, D]、after：[E, C, F, G]，我们设置了四个哨兵节点，oldStartIdx、newStartIdx、oldEndIdx、newEndIdx分别指向新旧节点数组的起始下标和开始下标，值为0,0,3,3；oldStartVnode，newStartVnode，oldEndVnode，newEndVnode则分别指向了before和after节点列表中对应哨兵节点下标的值，值为before[oldStartVnode],after[newStartIdx],before[oldEndIdx],after[newEndIdx]。</p>
<h5 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h5><p>当哨兵满足oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx的条件的时候，我们会循环进行一系列节点之间的比较。</p>
<h5 id="优先判断"><a href="#优先判断" class="headerlink" title="优先判断"></a>优先判断</h5><p>我们首先对上面声明的各个节点进行一些优先级较高的判断。</p>
<p>判断1：oldStartVnode是否为空，若为true则oldStartIdx向后移动，继续下一个节点的判断。判断代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">    <span class="comment">// 更新哨兵</span></span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断2：oldEndVnode是否为空，若为true则oldEndIdx向前移动。判断代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断3：使用 sameVnode判断before和after未判断的头节点是否为相同节点，若为true，则按照上面思路说的，对相同类型节点进行节点的属性的更新并修改哨兵位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sameVnode为判断节点是否相等的方法，包括key、tag、isComment等各个属性的相等才能算作相同节点</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">    <span class="comment">// 更新节点内容</span></span><br><span class="line">    patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">    <span class="comment">// 更新哨兵</span></span><br><span class="line">    oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">    newStartVnode = newCh[++newStartIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue双向绑定过程</title>
    <url>//56/</url>
    <content><![CDATA[<h3 id="Vue双向绑定过程"><a href="#Vue双向绑定过程" class="headerlink" title="Vue双向绑定过程"></a>Vue双向绑定过程</h3><p>vue2的和vue3的双向绑定区别，优势等</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>keep-alive组件原理</title>
    <url>//57/</url>
    <content><![CDATA[<h3 id="keep-alive组件原理"><a href="#keep-alive组件原理" class="headerlink" title="keep-alive组件原理"></a>keep-alive组件原理</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>keep-alive 是 Vue 的内置组件，当它包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 transition 相似，keep-alive 是一个抽象组件：它自身不会渲染成一个 DOM 元素，也不会出现在父组件链中。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在组件切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在 created 函数调用时将需要缓存的 VNode 节点保存在 this.cache 中／在 render（页面渲染） 时，如果 VNode 的 name 符合缓存条件（可以用 include 以及 exclude 控制），则会从 this.cache 中取出之前缓存的 VNode 实例进行渲染。</p>
<p>VNode：虚拟DOM，其实就是一个JS对象</p>
<span id="more"></span>

<h4 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h4><ul>
<li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li>max - 数字。最多可以缓存多少组件实例。</li>
</ul>
<h4 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h4><ol>
<li>activated</li>
</ol>
<ul>
<li>在 keep-alive 组件激活时调用</li>
<li>该钩子函数在服务器端渲染期间不被调用</li>
</ul>
<ol start="2">
<li>deactivated</li>
</ol>
<ul>
<li>在 keep-alive 组件停用时调用</li>
<li>该钩子在服务器端渲染期间不被调用</li>
</ul>
<p>被包含在 keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated</p>
<p>使用 keep-alive 会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在 activated 阶段获取数据，承担原来 created 钩子函数中获取数据的任务。</p>
<p>注意： 只有组件被 keep-alive 包裹时，这两个生命周期函数才会被调用，如果作为正常组件使用，是不会被调用的，以及在 2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 keep-alive 中，这两个钩子函数依然不会被调用！另外，在服务端渲染时，此钩子函数也不会被调用。</p>
<h4 id="缓存所有页面"><a href="#缓存所有页面" class="headerlink" title="缓存所有页面"></a>缓存所有页面</h4><ol>
<li>在 App.vue 里面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  	&lt;keep-alive&gt;</span><br><span class="line">      &lt;router-view&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;keep-alive&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="根据条件缓存页面"><a href="#根据条件缓存页面" class="headerlink" title="根据条件缓存页面"></a>根据条件缓存页面</h4><ol>
<li>在 App.vue 里面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  	&#x2F;&#x2F; 1. 将缓存 name 为 test 的组件</span><br><span class="line">  	&lt;keep-alive include&#x3D;&#39;test&#39;&gt;</span><br><span class="line">      &lt;router-view&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;keep-alive&gt;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 2. 将缓存 name 为 a 或者 b 的组件，结合动态组件使用</span><br><span class="line">	&lt;keep-alive include&#x3D;&#39;a,b&#39;&gt;</span><br><span class="line">  	  &lt;router-view&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;keep-alive&gt;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 3. 使用正则表达式，需使用 v-bind</span><br><span class="line">	&lt;keep-alive :include&#x3D;&#39;&#x2F;a|b&#x2F;&#39;&gt;</span><br><span class="line">  	  &lt;router-view&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;keep-alive&gt;	</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 5.动态判断</span><br><span class="line">	&lt;keep-alive :include&#x3D;&#39;includedComponents&#39;&gt;</span><br><span class="line">  	  &lt;router-view&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;keep-alive&gt;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 5. 将不缓存 name 为 test 的组件</span><br><span class="line">	&lt;keep-alive exclude&#x3D;&#39;test&#39;&gt;</span><br><span class="line">  	  &lt;router-view&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;keep-alive&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="结合Router，缓存部分页面"><a href="#结合Router，缓存部分页面" class="headerlink" title="结合Router，缓存部分页面"></a>结合Router，缓存部分页面</h4><ol>
<li>在 router 目录下的 index.js 文件里</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/home/home&#x27;</span>], resolve)</span><br><span class="line"><span class="keyword">const</span> Goods = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/home/goods&#x27;</span>], resolve)</span><br><span class="line"><span class="keyword">const</span> Ratings = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/home/ratings&#x27;</span>], resolve)</span><br><span class="line"><span class="keyword">const</span> Seller = <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/home/seller&#x27;</span>], resolve)</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes: [&#123;</span><br><span class="line">        path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        name: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        component: Home,</span><br><span class="line">        redirect: <span class="string">&#x27;goods&#x27;</span>,</span><br><span class="line">        children: [&#123;</span><br><span class="line">                path: <span class="string">&#x27;goods&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;goods&#x27;</span>,</span><br><span class="line">                component: Goods,</span><br><span class="line">                meta: &#123;</span><br><span class="line">                    keepAlive: <span class="literal">false</span> <span class="comment">// 不需要缓存</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: <span class="string">&#x27;ratings&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;ratings&#x27;</span>,</span><br><span class="line">                component: Ratings,</span><br><span class="line">                meta: &#123;</span><br><span class="line">                    keepAlive: <span class="literal">true</span> <span class="comment">// 需要缓存</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: <span class="string">&#x27;seller&#x27;</span>,</span><br><span class="line">                name: <span class="string">&#x27;seller&#x27;</span>,</span><br><span class="line">                component: Seller,</span><br><span class="line">                meta: &#123;</span><br><span class="line">                    keepAlive: <span class="literal">true</span> <span class="comment">// 需要缓存</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 App.vue 里面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  	&lt;keep-alive&gt;</span><br><span class="line">      &lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">    &lt;&#x2F;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if&#x3D;&quot;!$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>转发：<a href="https://blog.csdn.net/fu983531588/article/details/90321827">https://blog.csdn.net/fu983531588/article/details/90321827</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>父子组件生命周期</title>
    <url>//58/</url>
    <content><![CDATA[<h3 id="父子组件生命周期"><a href="#父子组件生命周期" class="headerlink" title="父子组件生命周期"></a>父子组件生命周期</h3><p>加载渲染过程<br>　　父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted<br>子组件更新过程<br>　　父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated<br>父组件更新过程<br>　　父beforeUpdate-&gt;父updated<br>销毁过程<br>　　父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件间如何通信</title>
    <url>//59/</url>
    <content><![CDATA[<h3 id="Vue组件间如何通信"><a href="#Vue组件间如何通信" class="headerlink" title="Vue组件间如何通信"></a>Vue组件间如何通信</h3><p>组件是 vue.js 最强大的功能之一，而组件实例的作用域是相互独立的，这就意味着不同组件之间的数据无法相互引用。一般来说，组件可以有以下几种关系：</p>
<p><img src="/59/59-1.png"></p>
<p>如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。</p>
<p>vue 组件间通信的几种方式，如 props、$emit/$on、vuex、$parent / $children、$attrs/$listeners和 provide/inject。</p>
<span id="more"></span>

<h4 id="props-emit"><a href="#props-emit" class="headerlink" title="props/$emit"></a>props/$emit</h4><p>父组件 A 通过 props 的方式向子组件 B 传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。</p>
<ol>
<li>父组件向子组件传值</li>
</ol>
<p>接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件 Users.vue 中如何获取父组件 App.vue 中的数据 users:[“Henry”,”Bucky”,”Emily”]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;App.vue父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;users v-bind:users&#x3D;&quot;users&quot;&gt;&lt;&#x2F;users&gt;&#x2F;&#x2F;前者自定义名称便于子组件调用，后者要传递数据名</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Users from &quot;.&#x2F;components&#x2F;Users&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    &quot;users&quot;:Users</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96;vue</span><br><span class="line">&#x2F;&#x2F;users子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;hello&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for&#x3D;&quot;user in users&quot;&gt;&#123;&#123;user&#125;&#125;&lt;&#x2F;li&gt;&#x2F;&#x2F;遍历传递过来的值，然后呈现到页面</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;HelloWorld&#39;,</span><br><span class="line">  props:&#123;</span><br><span class="line">    users:&#123;           &#x2F;&#x2F;这个就是父组件中子标签自定义名字</span><br><span class="line">      type:Array,</span><br><span class="line">      required:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>总结：父组件通过 props 向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed</p>
<ol start="2">
<li>子组件向父组件传值（通过事件形式）</li>
</ol>
<p>接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;h1 @click&#x3D;&quot;changeTitle&quot;&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;h1&gt;&#x2F;&#x2F;绑定一个点击事件</span><br><span class="line">  &lt;&#x2F;header&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;app-header&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title:&quot;Vue.js Demo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    changeTitle() &#123;</span><br><span class="line">      this.$emit(&quot;titleChanged&quot;,&quot;子向父组件传值&quot;);&#x2F;&#x2F;自定义事件  传递值“子向父组件传值”</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;app-header @titleChanged&#x3D;&quot;updateTitle&quot; &gt;&lt;&#x2F;app-header&gt;&#x2F;&#x2F;与子组件titleChanged自定义事件保持一致</span><br><span class="line">   &#x2F;&#x2F; updateTitle($event)接受传递过来的文字</span><br><span class="line">    &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Header from &quot;.&#x2F;components&#x2F;Header&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      title:&quot;传递的是一个值&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    updateTitle(e)&#123;   &#x2F;&#x2F;声明这个函数</span><br><span class="line">      this.title &#x3D; e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">   &quot;app-header&quot;:Header,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>总结：子组件通过events给父组件发送信息，实际上就是子组件把自己的数据发送到父组件</p>
<h3 id="emit-on"><a href="#emit-on" class="headerlink" title="$emit/$on"></a>$emit/$on</h3><p>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级。当我们的项目比较大时，可以选择更好的状态管理解决方案 vuex。</p>
<ol>
<li><p>具体实现方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Event = <span class="keyword">new</span> Vue();</span><br><span class="line">Event.$emit(事件名，数据)；</span><br><span class="line">Event.$on(事件名,<span class="function"><span class="params">data</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>举个例子</p>
</li>
</ol>
<p>假设兄弟组件有三个，分别是 A、B、C 组件，C 组件如何获取 A 或者 B 组件的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;itany&quot;&gt;</span><br><span class="line">	&lt;my-a&gt;&lt;&#x2F;my-a&gt;</span><br><span class="line">	&lt;my-b&gt;&lt;&#x2F;my-b&gt;</span><br><span class="line">	&lt;my-c&gt;&lt;&#x2F;my-c&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;a&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;A组件：&#123;&#123;name&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;send&quot;&gt;将数据发送给C组件&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;b&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;B组件：&#123;&#123;age&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;send&quot;&gt;将数组发送给C组件&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;template id&#x3D;&quot;c&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;C组件：&#123;&#123;name&#125;&#125;，&#123;&#123;age&#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Event &#x3D; new Vue();&#x2F;&#x2F;定义一个空的Vue实例</span><br><span class="line">var A &#x3D; &#123;</span><br><span class="line">	template: &#39;#a&#39;,</span><br><span class="line">	data() &#123;</span><br><span class="line">	  return &#123;</span><br><span class="line">	    name: &#39;tom&#39;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">	  send() &#123;</span><br><span class="line">	    Event.$emit(&#39;data-a&#39;, this.name);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var B &#x3D; &#123;</span><br><span class="line">	template: &#39;#b&#39;,</span><br><span class="line">	data() &#123;</span><br><span class="line">	  return &#123;</span><br><span class="line">	    age: 20</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	methods: &#123;</span><br><span class="line">	  send() &#123;</span><br><span class="line">	    Event.$emit(&#39;data-b&#39;, this.age);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var C &#x3D; &#123;</span><br><span class="line">	template: &#39;#c&#39;,</span><br><span class="line">	data() &#123;</span><br><span class="line">	  return &#123;</span><br><span class="line">	    name: &#39;&#39;,</span><br><span class="line">	    age: &quot;&quot;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	mounted() &#123;&#x2F;&#x2F;在模板编译完成后执行</span><br><span class="line">	 Event.$on(&#39;data-a&#39;,name &#x3D;&gt; &#123;</span><br><span class="line">	     this.name &#x3D; name;&#x2F;&#x2F;箭头函数内部不会产生新的this，这边如果不用&#x3D;&gt;,this指代Event</span><br><span class="line">	 &#125;)</span><br><span class="line">	 Event.$on(&#39;data-b&#39;,age &#x3D;&gt; &#123;</span><br><span class="line">	     this.age &#x3D; age;</span><br><span class="line">	 &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">	el: &#39;#itany&#39;,</span><br><span class="line">	components: &#123;</span><br><span class="line">	  &#39;my-a&#39;: A,</span><br><span class="line">	  &#39;my-b&#39;: B,</span><br><span class="line">	  &#39;my-c&#39;: C</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>$on 监听了自定义事件 data-a 和 data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。</p>
<h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><p><img src="/59/59-2.png"></p>
<ol>
<li>简要介绍 Vuex 原理</li>
</ol>
<p>Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 进行，Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action，但 Action 也是无法直接修改 State 的，还是需要通过 Mutation 来修改 State 的数据。最后，根据 State 的变化，渲染到视图上。</p>
<ol start="2">
<li>简要介绍各模块在流程中的功能：</li>
</ol>
<p>Vue Components：Vue 组件。HTML 页面上，负责接收用户操作等交互行为，执行 dispatch 方法触发对应 action 进行回应。<br>dispatch：操作行为触发方法，是唯一能执行 action 的方法。<br>actions：操作行为处理模块,由组件中的$store.dispatch(‘action 名称’, data1)来触发。然后由 commit()来触发 mutation 的调用 , 间接更新 state。负责处理 Vue Components 接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise 的封装，以支持 action 的链式触发。<br>commit：状态改变提交操作方法。对 mutation 进行提交，是唯一能执行 mutation 的方法。<br>mutations：状态改变操作方法，由 actions 中的commit(‘mutation 名称’)来触发。是 Vuex 修改 state 的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行 state 的监控等。<br>state：页面状态管理容器对象。集中存储 Vue components 中 data 对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行高效的状态更新。<br>getters：state 对象读取方法。图中没有单独列出该模块，应该被包含在了 render 中，Vue Components 通过该方法读取全局 state 对象。</p>
<ol start="3">
<li>Vuex 与 localStorage</li>
</ol>
<p>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在 vuex 里数据改变的时候把数据拷贝一份保存到 localStorage 里面，刷新之后，如果 localStorage 里有保存的数据，取出来再替换 store 里的 state。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultCity = <span class="string">&quot;上海&quot;</span></span><br><span class="line"><span class="keyword">try</span> &#123;   <span class="comment">// 用户关闭了本地存储功能，此时在外层加个try...catch</span></span><br><span class="line">  <span class="keyword">if</span> (!defaultCity)&#123;</span><br><span class="line">    defaultCity = <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;defaultCity&#x27;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: defaultCity</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">changeCity</span>(<span class="params">state, city</span>)</span> &#123;</span><br><span class="line">      state.city = city</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;defaultCity&#x27;</span>, <span class="built_in">JSON</span>.stringify(state.city));</span><br><span class="line">      <span class="comment">// 数据改变的时候把数据拷贝一份保存到localStorage里面</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是：由于 vuex 里，我们保存的状态，都是数组，而 localStorage 只支持字符串，所以需要用 JSON 转换：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(state.subscribeList);   <span class="comment">// array -&gt; string</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&quot;subscribeList&quot;</span>));    <span class="comment">// string -&gt; array</span></span><br></pre></td></tr></table></figure>

<h4 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs/$listeners"></a>$attrs/$listeners</h4><ol>
<li>简介</li>
</ol>
<p>多级组件嵌套需要传递数据时，通常使用的方法是通过 vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此 Vue2.4 版本提供了另一种方法—-$attrs/$listeners</p>
<p>$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 interitAttrs 选项一起使用。<br>$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件<br>接下来我们看个跨级通信的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; index.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;浪里行舟&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;child-com1</span><br><span class="line">      :foo&#x3D;&quot;foo&quot;</span><br><span class="line">      :boo&#x3D;&quot;boo&quot;</span><br><span class="line">      :coo&#x3D;&quot;coo&quot;</span><br><span class="line">      :doo&#x3D;&quot;doo&quot;</span><br><span class="line">      title&#x3D;&quot;前端工匠&quot;</span><br><span class="line">    &gt;&lt;&#x2F;child-com1&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom1 &#x3D; () &#x3D;&gt; import(&quot;.&#x2F;childCom1.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; childCom1 &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      foo: &quot;Javascript&quot;,</span><br><span class="line">      boo: &quot;Html&quot;,</span><br><span class="line">      coo: &quot;CSS&quot;,</span><br><span class="line">      doo: &quot;Vue&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; childCom1.vue</span><br><span class="line">&lt;template class&#x3D;&quot;border&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;foo: &#123;&#123; foo &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;child-com2 v-bind&#x3D;&quot;$attrs&quot;&gt;&lt;&#x2F;child-com2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom2 &#x3D; () &#x3D;&gt; import(&quot;.&#x2F;childCom2.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childCom2</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false, &#x2F;&#x2F; 可以关闭自动挂载到组件根元素上的没有在props声明的属性</span><br><span class="line">  props: &#123;</span><br><span class="line">    foo: String &#x2F;&#x2F; foo作为props属性绑定</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); &#x2F;&#x2F; &#123; &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; childCom2.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;boo: &#123;&#123; boo &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;child-com3 v-bind&#x3D;&quot;$attrs&quot;&gt;&lt;&#x2F;child-com3&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom3 &#x3D; () &#x3D;&gt; import(&quot;.&#x2F;childCom3.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childCom3</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  props: &#123;</span><br><span class="line">    boo: String</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); &#x2F;&#x2F; &#123; &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; childCom3.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;childCom3: &#123;&#123; $attrs &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    coo: String,</span><br><span class="line">    title: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>如上图所示$attrs表示没有继承数据的对象，格式为{属性名：属性值}。Vue2.4 提供了$attrs , $listeners 来传递数据与事件，跨级组件之间的通讯变得更简单。</p>
<p>简单来说：$attrs与$listeners 是两个对象，$attrs 里存放的是父组件中绑定的非 Props 属性，$listeners里存放的是父组件中绑定的非原生事件。</p>
<h4 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h4><ol>
<li>简介</li>
</ol>
<p>Vue2.2.0 新增 API,这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。一言而蔽之：祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。<br>provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</p>
<ol start="2">
<li>举个例子</li>
</ol>
<p>假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件</p>
<p>转发：<a href="https://www.cnblogs.com/fundebug/p/10884896.html">https://www.cnblogs.com/fundebug/p/10884896.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 对象</title>
    <url>//6/</url>
    <content><![CDATA[<h3 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是异步编程的一种解决方案。</p>
<p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>
<span id="more"></span>

<h4 id="Promise-状态"><a href="#Promise-状态" class="headerlink" title="Promise 状态"></a>Promise 状态</h4><h5 id="状态的特点"><a href="#状态的特点" class="headerlink" title="状态的特点"></a>状态的特点</h5><p>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。</p>
<p>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;  </span><br><span class="line">    resolve(<span class="string">&#x27;success3&#x27;</span>); </span><br><span class="line">    reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success1</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="状态的缺点"><a href="#状态的缺点" class="headerlink" title="状态的缺点"></a>状态的缺点</h5><p>无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。</p>
<p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p>
<p>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h5 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h5><p>then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。</p>
<h5 id="then-方法的特点"><a href="#then-方法的特点" class="headerlink" title="then 方法的特点"></a>then 方法的特点</h5><p>在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;first&#x27;</span>);</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>

<p>通过 .then 形式添加的回调函数，不论什么时候，都会被调用。</p>
<p>通过多次调用 .then ,可以添加多个回调函数，它们会按照插入顺序并且独立运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 第一个then // 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 第二个then // 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 第三个then // undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 第四个then // resolve</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;reject&#x27;</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 第五个then //reject:reject</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve:&#x27;</span> + value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;reject:&#x27;</span> + err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。</p>
<h5 id="then-方法注意点"><a href="#then-方法注意点" class="headerlink" title="then 方法注意点"></a>then 方法注意点</h5><p>简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。<br>注意总是返回或终止 Promise 链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  p2(result).then(<span class="function"><span class="params">newResult</span> =&gt;</span> p3(newResult));</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> p4());</span><br></pre></td></tr></table></figure>
<p>创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。<br>大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 .catch(error =&gt; console.log(error));</p>
<h5 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h5><p>Promise 的调用方式，new Promise(executor)， executor 两个参数，resolve，reject。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> resolve = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">       <span class="keyword">const</span> reject = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">       executor(resolve, rejcet)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise 内部有三个状态，pending、fulfilled、rejected，初始是 pending，调用 resolve 后变为 fulfilled,，调用 reject 后变为 rejected。fulfilled 时会调用 then 注册的成功的回调，rejected 时会调用 then 注册的失败的回调。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 内部状态</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123; <span class="attr">PENDING</span>: <span class="string">&#x27;PENDING&#x27;</span>, <span class="attr">FUFILLED</span>: <span class="string">&#x27;FUFILLED&#x27;</span>, <span class="attr">REJECTED</span>: <span class="string">&#x27;REJECTED&#x27;</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = STATUS.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">undefined</span>; <span class="comment">// 成过的值</span></span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">undefined</span>; <span class="comment">// 失败的值</span></span><br><span class="line">       <span class="built_in">this</span>.onResolvedCallbacks = []; <span class="comment">// 存放成功的回调的 </span></span><br><span class="line">       <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 存放失败的回调的</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status == STATUS.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = STATUS.FUFILLED;</span><br><span class="line">                <span class="built_in">this</span>.value = val;</span><br><span class="line">                <span class="comment">// 成功时调用成功队列里的回调</span></span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status == STATUS.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = STATUS.REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.reason = reason;</span><br><span class="line">                <span class="comment">// 失败时调用失败队列里的回调</span></span><br><span class="line">               <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 出错走失败逻辑</span></span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123; <span class="comment">// swtich  作用域</span></span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.FUFILLED) &#123;</span><br><span class="line">                <span class="comment">// to....</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.REJECTED) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123; <span class="comment">// todo..</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        resolve(x);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123; <span class="comment">// todo..</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolve(x);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 规范版</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123; <span class="attr">PENDING</span>: <span class="string">&#x27;PENDING&#x27;</span>, <span class="attr">FUFILLED</span>: <span class="string">&#x27;FUFILLED&#x27;</span>, <span class="attr">REJECTED</span>: <span class="string">&#x27;REJECTED&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的promise 按照规范来写 就可以和别人的promise公用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">x, promise2, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 规范 2.3.1</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 == x) &#123; <span class="comment">// 防止自己等待自己完成</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 规范 2.3.3</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> &amp;&amp; x !== <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// x可以是一个对象 或者是函数</span></span><br><span class="line">        <span class="keyword">let</span> called;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.1</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 2.3.3.3</span></span><br><span class="line">                then.call(x, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3.3</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                    resolvePromise(y, promise2, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3.3</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3.2</span></span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x); <span class="comment">// 此时x 就是一个普通对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.3.4.1</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.3.4 </span></span><br><span class="line">            reject(e); <span class="comment">// 取then时抛出错误了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x); <span class="comment">// x是一个原始数据类型 不能是promise</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是proimise 直接就调用resolve</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = STATUS.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks = []; <span class="comment">// 存放成功的回调的 </span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 存放失败的回调的</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(val <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123; <span class="comment">// 是promise 就继续递归解析</span></span><br><span class="line">                <span class="keyword">return</span> val.then(resolve,reject)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status == STATUS.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = STATUS.FUFILLED;</span><br><span class="line">                <span class="built_in">this</span>.value = val;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status == STATUS.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = STATUS.REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.reason = reason;</span><br><span class="line">                <span class="comment">// 腹部</span></span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 出错走失败逻辑</span></span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123; <span class="comment">// swtich  作用域</span></span><br><span class="line">        <span class="comment">// 可选参数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">x</span> =&gt;</span> x</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span>? onRejected: <span class="function"><span class="params">err</span>=&gt;</span> &#123;<span class="keyword">throw</span> err&#125;</span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.FUFILLED) &#123;</span><br><span class="line">                <span class="comment">// to....</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.REJECTED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">                <span class="comment">// 装饰模式 切片编程</span></span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123; <span class="comment">// todo..</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                            resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123; <span class="comment">// todo..</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                            resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么data是一个函数，不是一个对象</title>
    <url>//60/</url>
    <content><![CDATA[<h3 id="为什么data是一个函数，不是一个对象"><a href="#为什么data是一个函数，不是一个对象" class="headerlink" title="为什么data是一个函数，不是一个对象"></a>为什么data是一个函数，不是一个对象</h3><p>data属性可以是一个函数也可以是一个对象，比如在vue实例中，它可以设置为对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    let vm &#x3D; new Vue(&#123;</span><br><span class="line">        el:&#39;#app&#39;,</span><br><span class="line">        data:&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>而在组件中就需要将data设置为函数类型了，因为我们知道vue组件是需要进行复用的，假设data属性是一个对象的话，就意味着组件在复用的时候，其中的data用的是一个内存地址，在组件A中的变动也会体现在组件B中，而如果data属性是一个函数就不会出现这样的问题，我们每次在调用组件的时候data函数都会为我们返回一个新的对象，由各组件独立维护。</p>
<p>其实就是因为对象是一个引用类型。</p>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;demo&#39;, &#123;</span><br><span class="line">  template: &#96;&lt;div&gt;&lt;&#x2F;div&gt;&#96;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    demo: &#39;ok&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;组件中data属性为对象会报错!!!</span><br></pre></td></tr></table></figure>

<p>组件中data属性正确的写法应该是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&#39;demo&#39;, &#123;</span><br><span class="line">   template: &#96;&lt;div&gt;&lt;&#x2F;div&gt;&#96;,</span><br><span class="line">   data()&#123;</span><br><span class="line">       return &#123;</span><br><span class="line">            demo:&#39;ok&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Object是引用数据类型，如果不用function返回，每个组件的data都是内存的同一个地址，一个数据改变了其他也改变了；</p>
<p>JavaScript只有函数构成作用域(注意理解作用域，只有函数 {} 构成作用域, 对象的 {} 以及 if(){}都不构成作用域) , data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。</p>
<p>组件是可复用的vue实例，一个组件被创建好之后，就可能被用在各个地方，而组件不管被复用了多少次，组件中的data数据都应该是相互隔离，互不影响的，基于这一理念，组件每复用一次，data数据就应该被复制一次，之后，当某一处复用的地方组件内data数据被改变时，其他复用地方组件的data数据不受影响</p>
<p>因为同一个组件可能被复用引入多次，如果是一个对象的话，对象是一个堆内存空间地址，如一个组件被复用了三次，那么当其中一个组件中的data被修改了，另外两个也会跟着发生变化。因为他们指向同一块内存空间。</p>
<p>解决办法就是变成一个函数呀，因为函数执行形成一个私有作用域，也就是可以开辟一块独立的内存空间，有自己的Prototype原型。就互不影响了。</p>
<p>组件中的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>new Vue的整个过程，大致经历了什么</title>
    <url>//61/</url>
    <content><![CDATA[<h3 id="new-Vue的整个过程，大致经历了什么"><a href="#new-Vue的整个过程，大致经历了什么" class="headerlink" title="new Vue的整个过程，大致经历了什么"></a>new Vue的整个过程，大致经历了什么</h3><p>从new Vue开始都大致执行了哪些重要的方法</p>
<ol>
<li>new Vue();</li>
<li>Vue.prototype._init();</li>
<li>Vue.prototype.$mount();</li>
<li>mountComponent();</li>
<li>new Watcher();</li>
<li>Watcher.prototype.get();</li>
<li>updateComponent();</li>
<li>Vue.prototype._render();</li>
<li>render();</li>
<li>createElement()</li>
<li>Vue.prototype._update();//这里面会执行vm.$el=vm.<strong>patch</strong>(),最终根vm的$el就有了真实dom值</li>
<li>Vue.prototype.<strong>patch</strong>();//这个应该是最重要的方法了，他返回了真实的dom节点。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>hash与history路由的区别</title>
    <url>//62/</url>
    <content><![CDATA[<h3 id="hash与history路由的区别"><a href="#hash与history路由的区别" class="headerlink" title="hash与history路由的区别"></a>hash与history路由的区别</h3><ol>
<li>hash路由在地址栏URL上有#，而history路由没有会好看一点</li>
<li>我们进行回车刷新操作，hash路由会加载到地址栏对应的页面，而history路由一般就404报错了（刷新是网络请求，没有后端准备时会报错）。</li>
<li>hash路由支持低版本的浏览器，而history路由是HTML5新增的API。</li>
<li>hash的特点在于它虽然出现在了URL中，但是不包括在http请求中，所以对于后端是没有一点影响的，所以改变hash不会重新加载页面，所以这也是单页面应用的必备。</li>
<li>history运用了浏览器的历史记录栈，之前有back,forward,go方法，之后在HTML5中新增了pushState（）和replaceState（）方法（需要特定浏览器的支持），它们提供了对历史记录进行修改的功能，不过在进行修改时，虽然改变了当前的URL，但是浏览器不会马上向后端发送请求。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>axios原理及面试题</title>
    <url>//63/</url>
    <content><![CDATA[<h3 id="axios原理"><a href="#axios原理" class="headerlink" title="axios原理"></a>axios原理</h3><p>createInstance底层根据默认设置 新建一个Axios对象， axios中所有的请求[axios, axios.get, axios.<br>post等…]内部调用的都是Axios.prototype.request, 将Axios.prototype.request的内部this绑定到新建的<br>Axios对象上, 从而形成一个axios实例。新建一个Axios对象时，会有两个拦截器，request拦截器，response拦<br>截器。</p>
<span id="more"></span>

<h4 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h4><p>请求拦截器的作用是在请求发送前进行一些操作，例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么，例如加入token</span></span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">    timeout: <span class="number">15000</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在请求头中加token</span></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        <span class="comment">// 判断是否存在token，如果存在的话，则每个http header都加上token</span></span><br><span class="line">        <span class="keyword">let</span> token = sessionStorage.getItem(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (!config.headers.hasOwnProperty(<span class="string">&#x27;token&#x27;</span>) &amp;&amp; token) &#123;</span><br><span class="line">            <span class="keyword">if</span> (config.url !== <span class="string">&quot;/api_src/sm/auth/refreshToken&quot;</span>) &#123;</span><br><span class="line">                config.headers.Authorization = <span class="string">&quot;Bearer &quot;</span> + token</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="接口认证方式：Bearer-Token"><a href="#接口认证方式：Bearer-Token" class="headerlink" title="接口认证方式：Bearer Token"></a>接口认证方式：Bearer Token</h5><p>因为HTTP协议是开放的，可以任人调用。所以，如果接口不希望被随意调用，就需要做访问权限的控制，认证是好的用户，才允许调用API。</p>
<p>定义：为了验证使用者的身份，需要客户端向服务器端提供一个可靠的验证信息，称为Token，这个token通常由Json数据格式组成，通过hash散列算法生成一个字符串，所以称为Json Web Token（Json表示令牌的原始值是一个Json格式的数据，web表示是在互联网传播的，token表示令牌，简称JWT)</p>
<p>JWT分为三部分：</p>
<p>第一部分：头部<br>{<br>“typ” : “JWT”,     （typ：类型）<br>“alg” : “HS256” （alg：算法，HS256表示哈希算法的mac值。SHA256/HmacSHA256，SHA256表示直接加密，HmacSHA256表示用秘钥进行加密。SHA(Secure[sɪˈkjʊə(r)]  Hash Algorithm [ˈælgərɪðəm]，安全散列算法)<br>HMAC(Hash Message Authentication [ɔ:ˌθentɪ’keɪʃn] Code，散列消息鉴别码)）<br>}</p>
<p>第二部分（Claim正文部分）<br>{<br>“iss” : “joe”, （issuer，发布者）<br>“exp”: 1300819380, （expiration[ˌekspəˈreɪʃn]  time 过期时间，毫秒数计算）<br>“<a href="http://example.com/is_root&quot;">http://example.com/is_root&quot;</a> :true（主题）<br>}</p>
<p>第三部分：签名（将上面的两个部分组合在一起+本地信息做的一个的签名（头部在前）<br>网络解释: 签名是把header和payload（载荷）对应的json结构进行base64url编码之后得到的两个串，用英文句点号拼接起来，然后根据header里面alg指定的签名算法生成出来的。<br><a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-19">https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-19</a></p>
<ol>
<li>令牌的好处：避免在使用中不断的输入账号和密码，比较安全</li>
<li>如果要测试带token的接口，首先要进行登录，登录成功会有个token信息，向api接口发送请求的时候必须带上这个token，故需要做2次请求（1，登录，拿到token 2，正式对接口进行测试）</li>
</ol>
<p>这个时候头部会多一个authorization。</p>
<p>authorization可能在头部，也可能直接跟在请求行里面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.xxx.com&#x2F;ada?token&#x3D;xxxxx</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注意点：</li>
</ol>
<p>1）token一般有时间限制。测试前需要跟开发确认token可以用多久，什么时候算token失效<br>2）token放在哪儿，怎么传回去，需要有开发文档，或者咨询开发，登录成功返回的token需要了解从什么地方获取（可以通过录制进行查看）</p>
<h4 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h4><p>响应拦截器的作用是在接收到响应后进行一些操作，例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在接收响应做些什么，例如跳转到登录页</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// response interceptor</span></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> res = response.data</span><br><span class="line">        <span class="keyword">if</span> (res.success || res.FLAG === <span class="string">&#x27;SUCCESS&#x27;</span> || res.retCode === <span class="string">&#x27;200&#x27;</span> || res.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.code === <span class="string">&#x27;0420&#x27;</span>) &#123; <span class="comment">//不允许访问</span></span><br><span class="line">            Message(&#123;</span><br><span class="line">                message: res.msg || res.MESSAGE || res.message || <span class="string">&#x27;Error&#x27;</span>,</span><br><span class="line">                showClose: <span class="literal">true</span>,</span><br><span class="line">                type: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">                duration: <span class="number">2000</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.code === <span class="string">&#x27;1000&#x27;</span>) &#123; <span class="comment">//异常</span></span><br><span class="line">            Message(&#123;</span><br><span class="line">                message: <span class="string">&#x27;token信息失效，请重新登录&#x27;</span>,</span><br><span class="line">                showClose: <span class="literal">true</span>,</span><br><span class="line">                type: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">                duration: <span class="number">2000</span></span><br><span class="line">            &#125;)</span><br><span class="line">            storageClear()</span><br><span class="line">            router.replace(&#123;</span><br><span class="line">                path: <span class="string">&#x27;/login&#x27;</span> <span class="comment">// 到登录页重新获取token</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.code === <span class="string">&#x27;1010&#x27;</span>) &#123; <span class="comment">//失效  </span></span><br><span class="line">            <span class="comment">// 更新token的方法</span></span><br><span class="line">            <span class="keyword">const</span> tokenParams = sessionStorage.getItem(<span class="string">&quot;refreshToken&quot;</span>) ?? <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (tokenParams) &#123;</span><br><span class="line">                <span class="keyword">let</span> reback = doRequest(tokenParams, service, response)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(reback)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message(&#123;</span><br><span class="line">                message: res.msg || res.MESSAGE || res.message || <span class="string">&#x27;Error&#x27;</span>,</span><br><span class="line">                showClose: <span class="literal">true</span>,</span><br><span class="line">                type: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">                duration: <span class="number">2000</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (error.response?.status === <span class="number">401</span>) &#123;</span><br><span class="line">            Message(&#123;</span><br><span class="line">                message: <span class="string">&#x27;token信息失效，请重新登录&#x27;</span>,</span><br><span class="line">                showClose: <span class="literal">true</span>,</span><br><span class="line">                type: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">                duration: <span class="number">2000</span></span><br><span class="line">            &#125;)</span><br><span class="line">            storageClear()</span><br><span class="line">            router.replace(&#123;</span><br><span class="line">                path: <span class="string">&#x27;/login&#x27;</span> <span class="comment">// 到登录页重新获取token</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message(&#123;</span><br><span class="line">                message: error.message,</span><br><span class="line">                showClose: <span class="literal">true</span>,</span><br><span class="line">                type: <span class="string">&#x27;error&#x27;</span>,</span><br><span class="line">                duration: <span class="number">2000</span></span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">doRequest</span>(<span class="params">tokenParams, service, response</span>) </span>&#123;</span><br><span class="line">    sessionStorage.setItem(<span class="string">&quot;refreshTokenFlag&quot;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> getBack = refreshToken(tokenParams, service, response)</span><br><span class="line">    <span class="keyword">return</span> getBack</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="axios的特点有哪些"><a href="#axios的特点有哪些" class="headerlink" title="axios的特点有哪些"></a>axios的特点有哪些</h4><ol>
<li>Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API</li>
<li>它可以拦截请求和响应</li>
<li>它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据</li>
<li>安全性更高，客户端支持防御 XSRF</li>
</ol>
<h4 id="axios有哪些常用方法"><a href="#axios有哪些常用方法" class="headerlink" title="axios有哪些常用方法"></a>axios有哪些常用方法</h4><ol>
<li>axios.get(url[, config]) //get请求用于列表和信息查询</li>
<li>axios.delete(url[, config]) //删除</li>
<li>axios.post(url[, data[, config]]) //post请求用于信息的添加</li>
<li>axios.put(url[, data[, config]]) //更新操作</li>
</ol>
<h4 id="说下你了解的axios相关配置属性"><a href="#说下你了解的axios相关配置属性" class="headerlink" title="说下你了解的axios相关配置属性"></a>说下你了解的axios相关配置属性</h4><p>url是用于请求的服务器URL</p>
<p>method是创建请求时使用的方法, 默认是get</p>
<p>baseURL将自动加在url前面，除非url是一个绝对URL。它可以通过设置一个baseURL便于为axios实例的方法传递相对URL</p>
<p>transformRequest允许在向服务器发送前，修改请求数据，只能用在’PUT’, ‘POST’和’PATCH’这几个请求方法</p>
<p>headers是即将被发送的自定义请求头<br>headers:{‘X-Requested-With’:’XMLHttpRequest’}, </p>
<p>params是即将与请求一起发送的URL参数，必须是一个无格式对象(plainobject)或URLSearchParams对象<br>params:{<br>ID:12345<br>}, </p>
<p>auth表示应该使用HTTP基础验证，并提供凭据<br>这将设置一个Authorization头，覆写掉现有的任意使用headers设置的自定义Authorization头<br>auth:{<br>username:’janedoe’,<br>password:’s00pers3cret’<br>}, </p>
<p>‘proxy’定义代理服务器的主机名称和端口<br>auth表示HTTP基础验证应当用于连接代理，并提供凭据<br>这将会设置一个Proxy-Authorization头，覆写掉已有的通过使用header设置的自定义Proxy-Authorization头。<br>proxy:{<br>host:’127.0.0.1’,<br>port:9000,<br>auth::{<br>username:’mikeymike’,<br>password:’rapunz3l’<br>}<br>}, </p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>http请求</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins部署前端项目</title>
    <url>//64/</url>
    <content><![CDATA[<h3 id="Jenkins自动化部署"><a href="#Jenkins自动化部署" class="headerlink" title="Jenkins自动化部署"></a>Jenkins自动化部署</h3><h4 id="Jenkins服务器搭建及基本配置"><a href="#Jenkins服务器搭建及基本配置" class="headerlink" title="Jenkins服务器搭建及基本配置"></a>Jenkins服务器搭建及基本配置</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。</p>
<h5 id="Jenkins自动化部署实现原理"><a href="#Jenkins自动化部署实现原理" class="headerlink" title="Jenkins自动化部署实现原理"></a>Jenkins自动化部署实现原理</h5><p><img src="/64/64-1.png"></p>
<h5 id="Jenkins部署环境"><a href="#Jenkins部署环境" class="headerlink" title="Jenkins部署环境"></a>Jenkins部署环境</h5><p>基本环境：<br>1.jdk环境，Jenkins是java语言开发的，因需要jdk环境。<br>2.git/svn客户端，因一般代码是放在git/svn服务器上的，我们需要拉取代码。<br>3.maven客户端，因一般java程序是由maven工程，需要maven打包</p>
<h5 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a>Jenkins安装</h5><p>1.下载安装包jenkins.war；<br>2.在安装包根路径下，运行命令 java -jar jenkins.war –httpPort=8080，（linux环境、Windows环境都一样）；<br>3.打开浏览器进入链接 <a href="http://localhost:8080/">http://localhost:8080</a>.<br>4.填写初始密码，激活系统</p>
<p>转发：<a href="https://www.cnblogs.com/wfd360/p/11314697.html">https://www.cnblogs.com/wfd360/p/11314697.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>自动构建</tag>
      </tags>
  </entry>
  <entry>
    <title>实施前端微服务化的六七种方式</title>
    <url>//65/</url>
    <content><![CDATA[<p>转发：<a href="https://blog.csdn.net/qq_21793443/article/details/105293348">https://blog.csdn.net/qq_21793443/article/details/105293348</a><br><a href="https://zhuanlan.zhihu.com/p/59046576">https://zhuanlan.zhihu.com/p/59046576</a><br><a href="https://zhuanlan.zhihu.com/p/39102712">https://zhuanlan.zhihu.com/p/39102712</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>微前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise 经典面试题</title>
    <url>//7/</url>
    <content><![CDATA[<h3 id="Promise-经典面试题"><a href="#Promise-经典面试题" class="headerlink" title="Promise 经典面试题"></a>Promise 经典面试题</h3><p>可复制题目到<a href="https://www.sojson.com/runjs.html">js在线运行工具</a>看答案</p>
<span id="more"></span>

<h4 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>待解析</p>
<h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise then&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">script end</span><br><span class="line">promise then</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>首先 JavaScript 引擎会执行一个宏任务，注意这个宏任务一般是指主干代码本身，也就是目前的同步代码；</p>
<p>执行过程中如果遇到微任务，就把它添加到微任务任务队列中；</p>
<p>宏任务执行完成后，立即执行当前微任务队列中的微任务，直到微任务队列被清空；</p>
<p>微任务执行完成后，开始执行下一个宏任务；</p>
<p>如此循环往复，直到宏任务和微任务被清空。</p>
<h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h5 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h5 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h5><p>遇到 Promise 之后立即执行，输出 1，2<br>执行同步代码，输出 4<br>执行 promise.then() 中的代码，输出 3</p>
<h4 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h4><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">    reject(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then:&#x27;</span>, res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch:&#x27;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then: success1</span><br></pre></td></tr></table></figure>

<h5 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h5><p>这里考察了 promise 的单向传递的特点，promise 有三种状态：<br>pending<br>resolved<br>rejected<br>这三种状态的转移只能是 pending -&gt; resolved 或 pending -&gt; rejected。不会出现 resolved -&gt; rejected 或者 pending -&gt; resolved -&gt; rejected 等等，即状态只能从 pending 单向传递，且只能改变一次。<br>在 promise 中，resolve() 将 promise 的状态变为 resolved成功时调用，resolved 状态在先，先调用异步函数 promise.then((‘success1’) =&gt; { console.log(‘then:’, ‘success1’); })<br>promise 的状态一旦改变就不能修改了，因此 .catch() 和第二个 resolve(‘success2’) 不会执行。</p>
<h4 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h4><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">    .then(<span class="number">2</span>)</span><br><span class="line">    .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">    .then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>

<h5 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h5><p>.then() 中的参数必须是函数，如果是非函数，则会发生值穿透，最终执行第三个 .then() 函数，参数为 1。</p>
<h4 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h4><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h5 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h5><ol>
<li>promise.resolve() 返回一个新的 promise，执行第一个 .then()，参数为 1</li>
<li>打印 1，return 返回一个新的 promise，参数为 2</li>
<li>执行第二个 .then()，参数为 2，并打印出 2</li>
</ol>
<h4 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h4><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;then: &#x27;</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;catch: &#x27;</span>, err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then:  Error: error!!!</span><br></pre></td></tr></table></figure>

<h5 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h5><p>这里的陷阱在于只有抛出错误时才会执行 .catch()，题目中并不是抛出错误，所以执行 .then()。</p>
<p>改成如下方式会执行 .catch():</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>))</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h4><h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">    &#125;)</span><br><span class="line">promise.catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure>

<h5 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h5><p>程序报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></table></figure>

<h5 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h5><p>.then() 或 .catch() 返回的值不能是 promise 本身，否则会造成死循环。</p>
<h4 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h4><h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h5 id="答案-7"><a href="#答案-7" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h5 id="解读-1"><a href="#解读-1" class="headerlink" title="解读"></a>解读</h5><p>先执行整体代码，没有发现微任务；<br>再执行下一个宏任务—setTimeout回调函数，打印出1；<br>遇到微任务—Promise 回调函数；<br>立即执行微任务，打印出3；<br>微任务队列被清空，执行下一个宏任务—下一个setTimeout回调函数，打印出2。</p>
<h4 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h4><h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    res(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">pro.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="答案-8"><a href="#答案-8" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h5 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h5><p>promise 对象赋值给了变量 pro，每个 .then() 都是独立的。</p>
<h4 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h4><h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="答案-9"><a href="#答案-9" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<h5 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h5><p>注意以下几点:</p>
<ol>
<li>定义 async1()，async2()，不会立即执行</li>
<li>await async2(); 表示先执行 async2()，然后将 await 后面的代码当作 .then() 中的回调来处理</li>
<li>初始化 promise，promise 中的代码会立即执行</li>
</ol>
<p>转自：<a href="https://leetcode-cn.com/circle/discuss/sQXY3u/">https://leetcode-cn.com/circle/discuss/sQXY3u/</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常考算法题</title>
    <url>//66/</url>
    <content><![CDATA[<h3 id="前端常考算法题"><a href="#前端常考算法题" class="headerlink" title="前端常考算法题"></a>前端常考算法题</h3><ol start="209">
<li>长度最小的子数组    4</li>
</ol>
<p><img src="/66/66-1.gif"></p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力解法 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    public:</span><br><span class="line">        int <span class="function"><span class="title">minSubArrayLen</span>(<span class="params">int s, vector &lt; int &gt; &amp; nums</span>)</span> &#123;</span><br><span class="line">            int result = INT32_MAX; <span class="comment">// 最终的结果</span></span><br><span class="line">            int sum = <span class="number">0</span>; <span class="comment">// 子序列的数值之和    </span></span><br><span class="line">            int subLength = <span class="number">0</span>; <span class="comment">// 子序列的长度</span></span><br><span class="line">            <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123; <span class="comment">// 设置子序列起点为i</span></span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (int j = i; j &lt; nums.size(); j++) &#123; <span class="comment">// 设置子序列终止位置为j</span></span><br><span class="line">                    sum += nums[j];</span><br><span class="line">                    <span class="keyword">if</span> (sum &gt;= s) &#123; <span class="comment">// 一旦发现子序列和超过了s，更新result</span></span><br><span class="line">                        subLength = j - i + <span class="number">1</span>; <span class="comment">// 取子序列的长度</span></span><br><span class="line">                        result = result &lt; subLength ? result : subLength;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 因为我们是找符合条件最短的子序列，所以一旦符合条件就break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span></span><br><span class="line">            <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//滑动窗口解法</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">target, nums</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 长度计算一次</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> l = r = sum = <span class="number">0</span>,</span><br><span class="line">        res = len + <span class="number">1</span>; <span class="comment">// 子数组最大不会超过自身</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt; len) &#123;</span><br><span class="line">        sum += nums[r++];</span><br><span class="line">        <span class="comment">// 窗口滑动</span></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">            <span class="comment">// r始终为开区间 [l, r)</span></span><br><span class="line">            res = res &lt; r - l ? res : r - l;</span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res &gt; len ? <span class="number">0</span> : res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">转：https:<span class="comment">//leetcode-cn.com/problems/minimum-size-subarray-sum/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hua-d-kb06/</span></span><br></pre></td></tr></table></figure>
<ol start="93">
<li><p>复原IP地址    2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> restoreIpAddresses = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> SEG_COUNT = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">const</span> segments = <span class="keyword">new</span> <span class="built_in">Array</span>(SEG_COUNT);</span><br><span class="line">    <span class="keyword">const</span> ans = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function">(<span class="params">s, segId, segStart</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span> (segId === SEG_COUNT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (segStart === s.length) &#123;</span><br><span class="line">                ans.push(segments.join(<span class="string">&#x27;.&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (segStart === s.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(segStart) === <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            segments[segId] = <span class="number">0</span>;</span><br><span class="line">            dfs(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">        <span class="keyword">let</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> segEnd = segStart; segEnd &lt; s.length; ++segEnd) &#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s.charAt(segEnd) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>) &#123;</span><br><span class="line">                segments[segId] = addr;</span><br><span class="line">                dfs(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>转：<a href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/fu-yuan-ipdi-zhi-by-leetcode-solution/">https://leetcode-cn.com/problems/restore-ip-addresses/solution/fu-yuan-ipdi-zhi-by-leetcode-solution/</a></p>
</li>
<li><p>数组中的第K个最大元素    2</p>
</li>
<li><p>翻转二叉树    2</p>
</li>
<li><p>二叉树的中序遍历    2</p>
</li>
<li><p>零钱兑换    1</p>
</li>
<li><p>求根到叶子节点数字之和    1</p>
</li>
<li><p>合并两个有序数组    1</p>
</li>
<li><p>买卖股票    1</p>
</li>
<li><p>二叉树中的最大路径和    1</p>
</li>
<li><p>二叉树的最大深度</p>
</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>EventLoop</title>
    <url>//8/</url>
    <content><![CDATA[<h3 id="js的EventLoop"><a href="#js的EventLoop" class="headerlink" title="js的EventLoop"></a>js的EventLoop</h3><p>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript就是单线程.</p>
<span id="more"></span>

<p>由于js是单线程的, 只有当上一个任务完成之后才会继续完成下一个任务, 如果前一个任务耗时很长，后一个任务就不得不一直等着。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p>
<h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p>
<h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p>
<pre class="mermaid">graph TD
A[任务进入执行栈] --> B{同步任务还是异步任务}
B -->|同步| C[主线程]
B -->|异步| D[任务队列]
C --> E[任务全部执行完毕]
E --> D[任务队列]
D --> C[主线程]</pre>

<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。<br>主线程从任务队列中读取事件, 这个过程是不断循环的, 所以整个的运行机制称为EventLoop</li>
</ol>
<h4 id="MacroTask（宏任务）"><a href="#MacroTask（宏任务）" class="headerlink" title="MacroTask（宏任务）"></a>MacroTask（宏任务）</h4><p>宏任务: macrotask 可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行, 每一个宏任务会从头到尾将这个任务执行完毕，不会执行其它）包括整体代码script，setTimeout，setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。</p>
<h4 id="MicroTask（微任务）"><a href="#MicroTask（微任务）" class="headerlink" title="MicroTask（微任务）"></a>MicroTask（微任务）</h4><p>微任务: MicroTask 可以理解是在当前 task 执行结束后立即执行的任务，包括Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    resolve() <span class="comment">// 加上resolve可执行.then里面的方法</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line"><span class="comment">//打印顺序 2 4 3 1</span></span><br></pre></td></tr></table></figure>

<p>首先整体代码是一个宏任务, 遇到setTimeout, 会创建另一个宏任务, 接着执行当前的宏任务, Promise 新建后就会立即执行。所以会首先打印2，then方法是一个微任务，遇到then，添加到微任务队列，代码接着执行会打印4。此时宏任务执行完毕，接着就会检查当前微任务队列是否有微任务，如果有，立即执行当前的微任务（也就是then 打印3），当前微任务执行完毕之后，开始执行下一轮的宏任务setTimeout，会打印1。</p>
<pre class="mermaid">graph TD
A[宏任务] --> B[执行结束]
B --> C{有微任务?}
C --> |有| D[执行所有微任务]
C --> |无| D[执行所有微任务]
D --> E[浏览器渲染]
E --> |下一个宏任务| A[宏任务]</pre>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">800</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        i == <span class="number">9999</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印顺序 2 10 3 5 4 1 9 7 8</span></span><br></pre></td></tr></table></figure>

<p>首先整体代码是一个宏任务, 遇到setTimeout, 会创建另一个宏任务, 接着执行当前的宏任务, Promise 新建后就会立即执行。所以会首先打印2 10 3 , then方法是一个微任务，遇到then，添加到微任务队列，代码接着执行会打印5。遇到第二个setTimeout，创建第三个宏任务。此时宏任务执行完毕，接着就会检查当前微任务队列是否有微任务，如果有，立即执行当前的微任务（也就是then 打印4），当前微任务执行完毕之后，开始执行下一轮的宏任务，打印 1, 当前宏任务无微任务，进入下一轮宏任务，打印 9，Promise 新建后就会立即执行，打印7，接着执行微任务里的then，打印 8。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>express框架</title>
    <url>//9/</url>
    <content><![CDATA[<h3 id="express框架"><a href="#express框架" class="headerlink" title="express框架"></a>express框架</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。<br>使用 Express 可以快速地搭建一个完整功能的网站。</p>
<span id="more"></span>

<h4 id="Express-框架核心特性"><a href="#Express-框架核心特性" class="headerlink" title="Express 框架核心特性"></a>Express 框架核心特性</h4><ol>
<li>可以设置中间件来响应 HTTP 请求。</li>
<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>
<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>
</ol>
<p>简单点说express就是一个封装了很多功能的包，而你只需要用简单的express的专属的一些代码便可解决本来正常较为复杂的代码，方便你使用</p>
<h4 id="使用express"><a href="#使用express" class="headerlink" title="使用express"></a>使用express</h4><ol>
<li>进入一个目录当作工作目录</li>
<li>然后通过 npm init 命令为你的应用创建一个package.json 文件。（其中会输入参数，但可回车使用默认参数）</li>
<li>然后使用npm install express –save安装express</li>
<li>然后在你工程文件中引入</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br></pre></td></tr></table></figure>

<h4 id="框架中目录结构"><a href="#框架中目录结构" class="headerlink" title="框架中目录结构"></a>框架中目录结构</h4><ol>
<li>app.js: 启动文件，或者说入口文件。</li>
<li>package.json: 存储着工程的信息及模块依赖，当在 dependencies 中添加依赖的模块时， 运行 npm install ，npm 会检查当前目录下的 package.json，并自动安装所有指定的模块。</li>
<li>node_modules: 存放 package.json 中安装的模块，当你在 package.json 添加依赖的模块并安装后，存放在这个文件夹下。</li>
<li>public: 存放 image、css、js 等文件。</li>
<li>routes: 存放路由文件。</li>
<li>views: 存放视图文件或者说模板文件。</li>
</ol>
<h5 id="app-js作用"><a href="#app-js作用" class="headerlink" title="app.js作用"></a>app.js作用</h5><p>通过require()加装了express、path等模块，以及routes文件夹下的index.js和users.js路由文件。</p>
<ol>
<li><p>生成一个express实例app。<br>var app = express(); </p>
</li>
<li><p>设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方, __dirname 为全局变量, 存储当前正在执行的脚本所在的目录。<br>app.set(‘views’, path.join(__dirname, ‘views’)); </p>
</li>
<li><p>设置视图模板引擎为 ejs。<br>app.set(‘view engine’, ‘ejs’); </p>
</li>
<li><p>加装解析json的中间件<br>app.use(bodyParser.json()); </p>
</li>
<li><p>加装日志中间件<br>app.use(logger(‘dev’)); </p>
</li>
<li><p>加载解析urlencoded请求体的中间件。<br>app.use(bodyParser.urlencoded({ extended: false })); </p>
</li>
<li><p>加载解析cookie的中间件。<br>app.use(cookieParser()); </p>
</li>
<li><p>设置public文件夹为存放静态文件的目录。<br>app.use(express.static(path.join(__dirname, ‘public’))); </p>
</li>
<li><p>路由控制器。<br>app.use(‘/‘, routes);<br>app.use(‘/users’, users); </p>
</li>
<li><p>捕获404错误，并转发到错误处理器。<br>app.use(function(req, res, next) {<br>var err = new Error(‘Not Found’);<br>err.status = 404;<br>next(err);<br>}); </p>
</li>
<li><p>开发环境下的错误处理器，将错误信息渲染error模版并显示到浏览器中。<br>if (app.get(‘env’) === ‘development’) {<br>app.use(function(err, req, res, next) {<br>res.status(err.status || 500);<br>res.render(‘error’, {<br>message: err.message,<br>error: err<br>});<br>});<br>}</p>
</li>
<li><p>生产环境下的错误处理器，不会将错误信息泄露给用户。<br>app.use(function(err, req, res, next) {<br>res.status(err.status || 500);<br>res.render(‘error’, {<br>message: err.message,<br>error: {}<br>});<br>}); </p>
</li>
<li><p>导出app实例供其他模块调用。</p>
</li>
</ol>
<p>module.exports = app; </p>
<h4 id="bin-www-文件"><a href="#bin-www-文件" class="headerlink" title="bin/www 文件"></a>bin/www 文件</h4><ol>
<li>#!/usr/bin/env node：表明是 node 可执行文件。</li>
<li>var debug = require(‘debug’)(‘blog’)：引入debug模块，打印调试日志。</li>
<li>var app = require(‘../app’)：引入我们上面导出的app实例。</li>
<li>app.set(‘port’, process.env.PORT || 3000)：设置端口号。</li>
<li>app.set(‘port’, normalizePort(process.env.PORT || ‘3000’);</li>
</ol>
<p>启动工程并监听3000端口，成功后打印Express server listening on port 3000。</p>
<h4 id="routes-index-js-文件"><a href="#routes-index-js-文件" class="headerlink" title="routes/index.js 文件"></a>routes/index.js 文件</h4><p>生成一个路由实例用来捕获访问主页的GET请求，导出这个路由并在app.js中通过app.use(‘/‘, routes); 加载。这样，当访问主页时，就会调用res.render(‘index’, { title: ‘Express’ });渲染views/index.ejs模版并显示到浏览器中。</p>
<h4 id="views-index-ejs-文件"><a href="#views-index-ejs-文件" class="headerlink" title="views/index.ejs 文件"></a>views/index.ejs 文件</h4><p>在渲染模板时我们传入了一个变量 title 值为 express 字符串，模板引擎会将所有 &lt;%= title %&gt; 替换为 express ，然后将渲染后生成的html显示到浏览器中，如上图所示。</p>
<p>转发：<a href="https://www.jianshu.com/p/06e2396c6df2">https://www.jianshu.com/p/06e2396c6df2</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
</search>
