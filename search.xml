<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Event Loop</title>
      <link href="2021/08/04/29/"/>
      <url>2021/08/04/29/</url>
      
        <content type="html"><![CDATA[<h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Event Loop是一个程序结构，用于等待和发送消息和事件。</p><blockquote><p>简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。</p></blockquote><span id="more"></span><p>上图主线程的绿色部分，还是表示运行时间，而橙色部分表示空闲时间。每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。</p><h4 id="event-loop-的执行规则："><a href="#event-loop-的执行规则：" class="headerlink" title="event loop 的执行规则："></a>event loop 的执行规则：</h4><ol><li>首先执行宏任务，这个宏任务一般指 主干代码，我们经常称之为同步代码；</li><li>执行过程中如果遇到了微任务，将其加入到微任务队列中；</li><li>执行完宏任务之后，开始执行微任务队列中的任务，直至微任务队列为空；</li><li>微任务执行完之后，开始执行下一个宏任务；</li><li>如何循环执行，直到宏任务和微任务都执行完。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客编辑常用工具</title>
      <link href="2021/08/04/0/"/>
      <url>2021/08/04/0/</url>
      
        <content type="html"><![CDATA[<ol><li>奥森图标（<a href="https://www.thinkcmf.com/font_awesome.html">Font Awesome</a>）提供丰富的矢量字体图标—通过CSS可以任意控制所有图标的大小 ，颜色，阴影。</li><li><a href="http://www.swig.org/exec.html">SWIG</a>是一个接口编译器，用于将用C和C ++编写的程序与脚本语言（例如Perl，Python，Ruby和Tcl）连接起来。它通过获取C / C ++头文件中的声明并使用它们来生成脚本语言访问基础C / C ++代码所需的包装器代码来工作。此外，SWIG提供了各种自定义功能，可让您定制包装过程以适合您的应用程序。<span id="more"></span></li><li><a href="https://hexo.io/zh-cn/docs/commands.html">hexo</a>常用指令:<br>（1）新建一篇博客</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>（2）生成静态文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">//</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>（3）本地运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">//</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>（4）在github上运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">//</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>例：<a href="https://xdw-h.github.io/">author blog</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>express框架</title>
      <link href="2021/08/04/9/"/>
      <url>2021/08/04/9/</url>
      
        <content type="html"><![CDATA[<h3 id="express框架"><a href="#express框架" class="headerlink" title="express框架"></a>express框架</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。<br>使用 Express 可以快速地搭建一个完整功能的网站。</p><span id="more"></span><h4 id="Express-框架核心特性"><a href="#Express-框架核心特性" class="headerlink" title="Express 框架核心特性"></a>Express 框架核心特性</h4><ol><li>可以设置中间件来响应 HTTP 请求。</li><li>定义了路由表用于执行不同的 HTTP 请求动作。</li><li>可以通过向模板传递参数来动态渲染 HTML 页面。</li></ol><p>简单点说express就是一个封装了很多功能的包，而你只需要用简单的express的专属的一些代码便可解决本来正常较为复杂的代码，方便你使用</p><h4 id="使用express"><a href="#使用express" class="headerlink" title="使用express"></a>使用express</h4><ol><li>进入一个目录当作工作目录</li><li>然后通过 npm init 命令为你的应用创建一个package.json 文件。（其中会输入参数，但可回车使用默认参数）</li><li>然后使用npm install express –save安装express</li><li>然后在你工程文件中引入</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br></pre></td></tr></table></figure><h4 id="框架中目录结构"><a href="#框架中目录结构" class="headerlink" title="框架中目录结构"></a>框架中目录结构</h4><ol><li>app.js: 启动文件，或者说入口文件。</li><li>package.json: 存储着工程的信息及模块依赖，当在 dependencies 中添加依赖的模块时， 运行 npm install ，npm 会检查当前目录下的 package.json，并自动安装所有指定的模块。</li><li>node_modules: 存放 package.json 中安装的模块，当你在 package.json 添加依赖的模块并安装后，存放在这个文件夹下。</li><li>public: 存放 image、css、js 等文件。</li><li>routes: 存放路由文件。</li><li>views: 存放视图文件或者说模板文件。</li></ol><h5 id="app-js作用"><a href="#app-js作用" class="headerlink" title="app.js作用"></a>app.js作用</h5><p>通过require()加装了express、path等模块，以及routes文件夹下的index.js和users.js路由文件。</p><ol><li><p>生成一个express实例app。<br>var app = express(); </p></li><li><p>设置 views 文件夹为存放视图文件的目录, 即存放模板文件的地方, __dirname 为全局变量, 存储当前正在执行的脚本所在的目录。<br>app.set(‘views’, path.join(__dirname, ‘views’)); </p></li><li><p>设置视图模板引擎为 ejs。<br>app.set(‘view engine’, ‘ejs’); </p></li><li><p>加装解析json的中间件<br>app.use(bodyParser.json()); </p></li><li><p>加装日志中间件<br>app.use(logger(‘dev’)); </p></li><li><p>加载解析urlencoded请求体的中间件。<br>app.use(bodyParser.urlencoded({ extended: false })); </p></li><li><p>加载解析cookie的中间件。<br>app.use(cookieParser()); </p></li><li><p>设置public文件夹为存放静态文件的目录。<br>app.use(express.static(path.join(__dirname, ‘public’))); </p></li><li><p>路由控制器。<br>app.use(‘/‘, routes);<br>app.use(‘/users’, users); </p></li><li><p>捕获404错误，并转发到错误处理器。<br>app.use(function(req, res, next) {<br>var err = new Error(‘Not Found’);<br>err.status = 404;<br>next(err);<br>}); </p></li><li><p>开发环境下的错误处理器，将错误信息渲染error模版并显示到浏览器中。<br>if (app.get(‘env’) === ‘development’) {<br>app.use(function(err, req, res, next) {<br>res.status(err.status || 500);<br>res.render(‘error’, {<br>message: err.message,<br>error: err<br>});<br>});<br>}</p></li><li><p>生产环境下的错误处理器，不会将错误信息泄露给用户。<br>app.use(function(err, req, res, next) {<br>res.status(err.status || 500);<br>res.render(‘error’, {<br>message: err.message,<br>error: {}<br>});<br>}); </p></li><li><p>导出app实例供其他模块调用。</p></li></ol><p>module.exports = app; </p><h4 id="bin-www-文件"><a href="#bin-www-文件" class="headerlink" title="bin/www 文件"></a>bin/www 文件</h4><ol><li>#!/usr/bin/env node：表明是 node 可执行文件。</li><li>var debug = require(‘debug’)(‘blog’)：引入debug模块，打印调试日志。</li><li>var app = require(‘../app’)：引入我们上面导出的app实例。</li><li>app.set(‘port’, process.env.PORT || 3000)：设置端口号。</li><li>app.set(‘port’, normalizePort(process.env.PORT || ‘3000’);</li></ol><p>启动工程并监听3000端口，成功后打印Express server listening on port 3000。</p><h4 id="routes-index-js-文件"><a href="#routes-index-js-文件" class="headerlink" title="routes/index.js 文件"></a>routes/index.js 文件</h4><p>生成一个路由实例用来捕获访问主页的GET请求，导出这个路由并在app.js中通过app.use(‘/‘, routes); 加载。这样，当访问主页时，就会调用res.render(‘index’, { title: ‘Express’ });渲染views/index.ejs模版并显示到浏览器中。</p><h4 id="views-index-ejs-文件"><a href="#views-index-ejs-文件" class="headerlink" title="views/index.ejs 文件"></a>views/index.ejs 文件</h4><p>在渲染模板时我们传入了一个变量 title 值为 express 字符串，模板引擎会将所有 &lt;%= title %&gt; 替换为 express ，然后将渲染后生成的html显示到浏览器中，如上图所示。</p><p>转发：<a href="https://www.jianshu.com/p/06e2396c6df2">https://www.jianshu.com/p/06e2396c6df2</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventLoop</title>
      <link href="2021/08/04/8/"/>
      <url>2021/08/04/8/</url>
      
        <content type="html"><![CDATA[<h3 id="js的EventLoop"><a href="#js的EventLoop" class="headerlink" title="js的EventLoop"></a>js的EventLoop</h3><p>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript就是单线程.</p><span id="more"></span><p>由于js是单线程的, 只有当上一个任务完成之后才会继续完成下一个任务, 如果前一个任务耗时很长，后一个任务就不得不一直等着。于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</p><h4 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h4><p>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</p><h4 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h4><p>不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[任务进入执行栈] --&gt; B&#123;同步任务还是异步任务&#125;</span><br><span class="line">B --&gt;|同步| C[主线程]</span><br><span class="line">B --&gt;|异步| D[任务队列]</span><br><span class="line">C --&gt; E[任务全部执行完毕]</span><br><span class="line">E --&gt; D[任务队列]</span><br><span class="line">D --&gt; C[主线程]</span><br></pre></td></tr></table></figure><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。<br>主线程从任务队列中读取事件, 这个过程是不断循环的, 所以整个的运行机制称为EventLoop</li></ol><h4 id="MacroTask（宏任务）"><a href="#MacroTask（宏任务）" class="headerlink" title="MacroTask（宏任务）"></a>MacroTask（宏任务）</h4><p>宏任务: macrotask 可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行, 每一个宏任务会从头到尾将这个任务执行完毕，不会执行其它）包括整体代码script，setTimeout，setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。</p><h4 id="MicroTask（微任务）"><a href="#MicroTask（微任务）" class="headerlink" title="MicroTask（微任务）"></a>MicroTask（微任务）</h4><p>微任务: MicroTask 可以理解是在当前 task 执行结束后立即执行的任务，包括Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    resolve() <span class="comment">// 加上resolve可执行.then里面的方法</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line"><span class="comment">//打印顺序 2 4 3 1</span></span><br></pre></td></tr></table></figure><p>首先整体代码是一个宏任务, 遇到setTimeout, 会创建另一个宏任务, 接着执行当前的宏任务, Promise 新建后就会立即执行。所以会首先打印2，then方法是一个微任务，遇到then，添加到微任务队列，代码接着执行会打印4。此时宏任务执行完毕，接着就会检查当前微任务队列是否有微任务，如果有，立即执行当前的微任务（也就是then 打印3），当前微任务执行完毕之后，开始执行下一轮的宏任务setTimeout，会打印1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[宏任务] --&gt; B[执行结束]</span><br><span class="line">B --&gt; C&#123;有微任务?&#125;</span><br><span class="line">C --&gt; |有| D[执行所有微任务]</span><br><span class="line">C --&gt; |无| D[执行所有微任务]</span><br><span class="line">D --&gt; E[浏览器渲染]</span><br><span class="line">E --&gt; |下一个宏任务| A[宏任务]</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">800</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">10</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        i == <span class="number">9999</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">8</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印顺序 2 10 3 5 4 1 9 7 8</span></span><br></pre></td></tr></table></figure><p>首先整体代码是一个宏任务, 遇到setTimeout, 会创建另一个宏任务, 接着执行当前的宏任务, Promise 新建后就会立即执行。所以会首先打印2 10 3 , then方法是一个微任务，遇到then，添加到微任务队列，代码接着执行会打印5。遇到第二个setTimeout，创建第三个宏任务。此时宏任务执行完毕，接着就会检查当前微任务队列是否有微任务，如果有，立即执行当前的微任务（也就是then 打印4），当前微任务执行完毕之后，开始执行下一轮的宏任务，打印 1, 当前宏任务无微任务，进入下一轮宏任务，打印 9，Promise 新建后就会立即执行，打印7，接着执行微任务里的then，打印 8。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async函数原理及使用方法</title>
      <link href="2021/08/04/4/"/>
      <url>2021/08/04/4/</url>
      
        <content type="html"><![CDATA[<h3 id="async函数原理及使用方法"><a href="#async函数原理及使用方法" class="headerlink" title="async函数原理及使用方法"></a>async函数原理及使用方法</h3><blockquote><p>async 函数是 Generator 函数的语法糖，async 函数的实现原理，就是将 <a href="/2021/08/04/5/" title="Generator函数">Generator函数</a>和自动执行器，包装在一个函数里。</p></blockquote><span id="more"></span><h4 id="1-Generator-函数"><a href="#1-Generator-函数" class="headerlink" title="1. Generator 函数"></a>1. Generator 函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span>(<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成async是：</span></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await。</p><h4 id="2-async具体使用和优点"><a href="#2-async具体使用和优点" class="headerlink" title="2.async具体使用和优点"></a>2.async具体使用和优点</h4><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeout(ms);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>上面代码指定 50 毫秒以后，输出hello world。</p><p>async异步函数变体：</p><blockquote><p>异步函数声明： async function foo() {}</p></blockquote><p>异步函数表达式： const foo = async function () {};<br>异步函数定义：let obj = { async foo() {} }<br>异步箭头函数： const foo = async () =&gt; {}; </p><blockquote></blockquote><p>理解：<br>1.async 表示这是一个 async 函数，而 await 只能在这个函数里面使用。<br>2.await 表示在这里等待 await 后面的操作执行完毕，再执行下一句代码。<br>3.await 后面紧跟着的最好是一个耗时的操作或者是一个异步操作(当然非耗时的操作也可以的，但是就失去意义了)。</p><h4 id="3-错误处理"><a href="#3-错误处理" class="headerlink" title="3. 错误处理"></a>3. 错误处理</h4><p>如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">    .then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// Error：出错了</span></span><br></pre></td></tr></table></figure><p>防止出错的方法，也是将其放在try…catch代码块之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> val1 = <span class="keyword">await</span> firstStep();</span><br><span class="line">        <span class="keyword">const</span> val2 = <span class="keyword">await</span> secondStep(val1);</span><br><span class="line">        <span class="keyword">const</span> val3 = <span class="keyword">await</span> thirdStep(val1, val2);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Final: &#x27;</span>, val3);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>async是一个Promis对象，我们可以在async后面加上then或者catch这个东西来防止出错。</p><p>转：<a href="https://www.cnblogs.com/luozhixiang/p/9116965.html">https://www.cnblogs.com/luozhixiang/p/9116965.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 Generator 函数</title>
      <link href="2021/08/04/5/"/>
      <url>2021/08/04/5/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6-Generator-函数"><a href="#ES6-Generator-函数" class="headerlink" title="ES6 Generator 函数"></a>ES6 Generator 函数</h3><p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。</p><h4 id="Generator-函数组成"><a href="#Generator-函数组成" class="headerlink" title="Generator 函数组成"></a>Generator 函数组成</h4><p>Generator 有两个区分于普通函数的部分：</p><ol><li>在 function 后面，函数名之前有个 * ；</li><li>函数内部有 yield 表达式。</li></ol><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h4><p>调用 Generator 函数和调用普通函数一样，在函数名后面加上()即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">f.next();</span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;1&quot;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// three</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one , 执行到 yield 就停下来，并将yield 后边表达式的值 ‘1’，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。</p><p>第二次调用 next 方法时，同上步 。</p><p>第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。</p><p>第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。</p><h4 id="函数返回的遍历器对象的方法"><a href="#函数返回的遍历器对象的方法" class="headerlink" title="函数返回的遍历器对象的方法"></a>函数返回的遍历器对象的方法</h4><h5 id="next-方法"><a href="#next-方法" class="headerlink" title="next 方法"></a>next 方法</h5><p>一般情况下，next 方法不传入参数的时候，yield 表达式的返回值是 undefined 。当 next 传入参数的时候，该参数会作为上一步yield的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">sendParameter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;one:&quot;</span> + x);</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;two:&quot;</span> + y);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;total:&quot;</span> + (x + y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next不传参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendp1 = sendParameter();</span><br><span class="line">sendp1.next();</span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">sendp1.next();</span><br><span class="line"><span class="comment">// one:undefined</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: false&#125;</span></span><br><span class="line">sendp1.next();</span><br><span class="line"><span class="comment">// two:undefined</span></span><br><span class="line"><span class="comment">// total:NaN</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//next传参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sendp2 = sendParameter();</span><br><span class="line">sendp2.next(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;2&quot;, done: false&#125;</span></span><br><span class="line">sendp2.next(<span class="number">20</span>);</span><br><span class="line"><span class="comment">// one:20</span></span><br><span class="line"><span class="comment">// &#123;value: &quot;3&quot;, done: false&#125;</span></span><br><span class="line">sendp2.next(<span class="number">30</span>);</span><br><span class="line"><span class="comment">// two:30</span></span><br><span class="line"><span class="comment">// total:50</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>除了使用 next ，还可以使用 for… of 循环遍历 Generator 函数生产的 Iterator 对象。</p><h5 id="return-方法"><a href="#return-方法" class="headerlink" title="return 方法"></a>return 方法</h5><p>return 方法返回给定值，并结束遍历 Generator 函数。</p><p>return 方法提供参数时，返回该参数；不提供参数时，返回 undefined 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = foo();</span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">f.return(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;value: &quot;foo&quot;, done: true&#125;</span></span><br><span class="line">f.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="keyword">throw</span> 方法</span><br><span class="line"><span class="keyword">throw</span> 方法可以再 Generator 函数体外面抛出异常， 再函数体内部捕获。</span><br><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;catch inner&#x27;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    i.throw(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    i.throw(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch outside&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// catch inner a</span></span><br><span class="line"><span class="comment">// catch outside b</span></span><br></pre></td></tr></table></figure><p>遍历器对象抛出了两个错误，第一个被 Generator 函数内部捕获，第二个因为函数体内部的catch 函数已经执行过了，不会再捕获这个错误，所以这个错误就抛出 Generator 函数体，被函数体外的 catch 捕获。</p><h4 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h4><p>yield* 表达式表示 yield 返回一个遍历器对象，用于在 Generator 函数内部，调用另一个 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">callee</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;callee: &#x27;</span> + (<span class="keyword">yield</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">caller</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span>* callee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> callerObj = caller();</span><br><span class="line">callerObj.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">callerObj.next(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">// callee: a</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">callerObj.next(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// callee: b</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">caller</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> callee) &#123;</span><br><span class="line">            <span class="keyword">yield</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><h5 id="实现-Iterator"><a href="#实现-Iterator" class="headerlink" title="实现 Iterator"></a>实现 Iterator</h5><p>为不具备 Iterator 接口的对象提供遍历方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> propKeys = <span class="built_in">Reflect</span>.ownKeys(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">        <span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> jane = &#123;</span><br><span class="line">    first: <span class="string">&#x27;Jane&#x27;</span>,</span><br><span class="line">    last: <span class="string">&#x27;Doe&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> objectEntries(jane)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><p>Reflect.ownKeys() 返回对象所有的属性，不管属性是否可枚举，包括 Symbol。</p><p>jane 原生是不具备 Iterator 接口无法通过 for… of遍历。这边用了 Generator 函数加上了 Iterator 接口，所以就可以遍历 jane 对象了。</p><p>转：<a href="https://www.runoob.com/w3cnote/es6-generator.html">https://www.runoob.com/w3cnote/es6-generator.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise 对象</title>
      <link href="2021/08/04/6/"/>
      <url>2021/08/04/6/</url>
      
        <content type="html"><![CDATA[<h3 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>是异步编程的一种解决方案。</p><p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p><span id="more"></span><h4 id="Promise-状态"><a href="#Promise-状态" class="headerlink" title="Promise 状态"></a>Promise 状态</h4><h5 id="状态的特点"><a href="#状态的特点" class="headerlink" title="状态的特点"></a>状态的特点</h5><p>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。</p><p>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;  </span><br><span class="line">    resolve(<span class="string">&#x27;success3&#x27;</span>); </span><br><span class="line">    reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success1</span></span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// success3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="状态的缺点"><a href="#状态的缺点" class="headerlink" title="状态的缺点"></a>状态的缺点</h5><p>无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。</p><p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p><p>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><h5 id="then-方法"><a href="#then-方法" class="headerlink" title="then 方法"></a>then 方法</h5><p>then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。</p><h5 id="then-方法的特点"><a href="#then-方法的特点" class="headerlink" title="then 方法的特点"></a>then 方法的特点</h5><p>在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;success&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;first&#x27;</span>);</span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure><p>通过 .then 形式添加的回调函数，不论什么时候，都会被调用。</p><p>通过多次调用 .then ,可以添加多个回调函数，它们会按照插入顺序并且独立运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 第一个then // 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 第二个then // 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 第三个then // undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;resolve&#x27;</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 第四个then // resolve</span></span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;reject&#x27;</span>); </span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123; <span class="comment">// 第五个then //reject:reject</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolve:&#x27;</span> + value);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;reject:&#x27;</span> + err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。</p><h5 id="then-方法注意点"><a href="#then-方法注意点" class="headerlink" title="then 方法注意点"></a>then 方法注意点</h5><p>简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。<br>注意总是返回或终止 Promise 链。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  p2(result).then(<span class="function"><span class="params">newResult</span> =&gt;</span> p3(newResult));</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> p4());</span><br></pre></td></tr></table></figure><p>创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。<br>大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 .catch(error =&gt; console.log(error));</p><h5 id="手写-Promise"><a href="#手写-Promise" class="headerlink" title="手写 Promise"></a>手写 Promise</h5><p>Promise 的调用方式，new Promise(executor)， executor 两个参数，resolve，reject。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> resolve = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">       <span class="keyword">const</span> reject = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">       executor(resolve, rejcet)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Promise 内部有三个状态，pending、fulfilled、rejected，初始是 pending，调用 resolve 后变为 fulfilled,，调用 reject 后变为 rejected。fulfilled 时会调用 then 注册的成功的回调，rejected 时会调用 then 注册的失败的回调。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise 内部状态</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123; <span class="attr">PENDING</span>: <span class="string">&#x27;PENDING&#x27;</span>, <span class="attr">FUFILLED</span>: <span class="string">&#x27;FUFILLED&#x27;</span>, <span class="attr">REJECTED</span>: <span class="string">&#x27;REJECTED&#x27;</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = STATUS.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">undefined</span>; <span class="comment">// 成过的值</span></span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">undefined</span>; <span class="comment">// 失败的值</span></span><br><span class="line">       <span class="built_in">this</span>.onResolvedCallbacks = []; <span class="comment">// 存放成功的回调的 </span></span><br><span class="line">       <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 存放失败的回调的</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status == STATUS.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = STATUS.FUFILLED;</span><br><span class="line">                <span class="built_in">this</span>.value = val;</span><br><span class="line">                <span class="comment">// 成功时调用成功队列里的回调</span></span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status == STATUS.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = STATUS.REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.reason = reason;</span><br><span class="line">                <span class="comment">// 失败时调用失败队列里的回调</span></span><br><span class="line">               <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 出错走失败逻辑</span></span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123; <span class="comment">// swtich  作用域</span></span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.FUFILLED) &#123;</span><br><span class="line">                <span class="comment">// to....</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.REJECTED) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123; <span class="comment">// todo..</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        resolve(x);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123; <span class="comment">// todo..</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolve(x);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规范版</span></span><br><span class="line"><span class="keyword">const</span> STATUS = &#123; <span class="attr">PENDING</span>: <span class="string">&#x27;PENDING&#x27;</span>, <span class="attr">FUFILLED</span>: <span class="string">&#x27;FUFILLED&#x27;</span>, <span class="attr">REJECTED</span>: <span class="string">&#x27;REJECTED&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的promise 按照规范来写 就可以和别人的promise公用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">x, promise2, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 规范 2.3.1</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 == x) &#123; <span class="comment">// 防止自己等待自己完成</span></span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 规范 2.3.3</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> &amp;&amp; x !== <span class="literal">null</span>) || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// x可以是一个对象 或者是函数</span></span><br><span class="line">        <span class="keyword">let</span> called;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.1</span></span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 2.3.3.3</span></span><br><span class="line">                then.call(x, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3.3</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">                    resolvePromise(y, promise2, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3.3</span></span><br><span class="line">                    <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">                    called = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 规范 2.3.3.3.2</span></span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(x); <span class="comment">// 此时x 就是一个普通对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.3.4.1</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.3.4 </span></span><br><span class="line">            reject(e); <span class="comment">// 取then时抛出错误了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x); <span class="comment">// x是一个原始数据类型 不能是promise</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不是proimise 直接就调用resolve</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = STATUS.PENDING;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallbacks = []; <span class="comment">// 存放成功的回调的 </span></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallbacks = []; <span class="comment">// 存放失败的回调的</span></span><br><span class="line">        <span class="keyword">const</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(val <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123; <span class="comment">// 是promise 就继续递归解析</span></span><br><span class="line">                <span class="keyword">return</span> val.then(resolve,reject)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status == STATUS.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = STATUS.FUFILLED;</span><br><span class="line">                <span class="built_in">this</span>.value = val;</span><br><span class="line">                <span class="comment">// 发布</span></span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status == STATUS.PENDING) &#123;</span><br><span class="line">                <span class="built_in">this</span>.status = STATUS.REJECTED;</span><br><span class="line">                <span class="built_in">this</span>.reason = reason;</span><br><span class="line">                <span class="comment">// 腹部</span></span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            executor(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            <span class="comment">// 出错走失败逻辑</span></span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123; <span class="comment">// swtich  作用域</span></span><br><span class="line">        <span class="comment">// 可选参数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function"><span class="params">x</span> =&gt;</span> x</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span>? onRejected: <span class="function"><span class="params">err</span>=&gt;</span> &#123;<span class="keyword">throw</span> err&#125;</span><br><span class="line">        <span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.FUFILLED) &#123;</span><br><span class="line">                <span class="comment">// to....</span></span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                        resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.REJECTED) &#123;</span><br><span class="line">                <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                        resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">                <span class="comment">// 装饰模式 切片编程</span></span><br><span class="line">                <span class="built_in">this</span>.onResolvedCallbacks.push(<span class="function">() =&gt;</span> &#123; <span class="comment">// todo..</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onFulfilled(<span class="built_in">this</span>.value);</span><br><span class="line">                            resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="built_in">this</span>.onRejectedCallbacks.push(<span class="function">() =&gt;</span> &#123; <span class="comment">// todo..</span></span><br><span class="line">                    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">let</span> x = onRejected(<span class="built_in">this</span>.reason);</span><br><span class="line">                            resolvePromise(x, promise2, resolve, reject)</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise 经典面试题</title>
      <link href="2021/08/04/7/"/>
      <url>2021/08/04/7/</url>
      
        <content type="html"><![CDATA[<h3 id="Promise-经典面试题"><a href="#Promise-经典面试题" class="headerlink" title="Promise 经典面试题"></a>Promise 经典面试题</h3><p>可复制题目到<a href="https://www.sojson.com/runjs.html">js在线运行工具</a>看答案</p><span id="more"></span><h4 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h4><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>待解析</p><h4 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h4><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise then&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">script end</span><br><span class="line">promise then</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>首先 JavaScript 引擎会执行一个宏任务，注意这个宏任务一般是指主干代码本身，也就是目前的同步代码；</p><p>执行过程中如果遇到微任务，就把它添加到微任务任务队列中；</p><p>宏任务执行完成后，立即执行当前微任务队列中的微任务，直到微任务队列被清空；</p><p>微任务执行完成后，开始执行下一个宏任务；</p><p>如此循环往复，直到宏任务和微任务被清空。</p><h4 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h4><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h5 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h5 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h5><p>遇到 Promise 之后立即执行，输出 1，2<br>执行同步代码，输出 4<br>执行 promise.then() 中的代码，输出 3</p><h4 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h4><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success1&#x27;</span>);</span><br><span class="line">    reject(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;success2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;then:&#x27;</span>, res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch:&#x27;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">then: success1</span><br></pre></td></tr></table></figure><h5 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h5><p>这里考察了 promise 的单向传递的特点，promise 有三种状态：<br>pending<br>resolved<br>rejected<br>这三种状态的转移只能是 pending -&gt; resolved 或 pending -&gt; rejected。不会出现 resolved -&gt; rejected 或者 pending -&gt; resolved -&gt; rejected 等等，即状态只能从 pending 单向传递，且只能改变一次。<br>在 promise 中，resolve() 将 promise 的状态变为 resolved成功时调用，resolved 状态在先，先调用异步函数 promise.then((‘success1’) =&gt; { console.log(‘then:’, ‘success1’); })<br>promise 的状态一旦改变就不能修改了，因此 .catch() 和第二个 resolve(‘success2’) 不会执行。</p><h4 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h4><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">    .then(<span class="number">2</span>)</span><br><span class="line">    .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">    .then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><h5 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h5 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h5><p>.then() 中的参数必须是函数，如果是非函数，则会发生值穿透，最终执行第三个 .then() 函数，参数为 1。</p><h4 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h4><h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h5 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h5 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h5><ol><li>promise.resolve() 返回一个新的 promise，执行第一个 .then()，参数为 1</li><li>打印 1，return 返回一个新的 promise，参数为 2</li><li>执行第二个 .then()，参数为 2，并打印出 2</li></ol><h4 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h4><h5 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;then: &#x27;</span>, res)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;catch: &#x27;</span>, err)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">then:  Error: error!!!</span><br></pre></td></tr></table></figure><h5 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h5><p>这里的陷阱在于只有抛出错误时才会执行 .catch()，题目中并不是抛出错误，所以执行 .then()。</p><p>改成如下方式会执行 .catch():</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>))</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error!!!&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h4><h5 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">    &#125;)</span><br><span class="line">promise.catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><h5 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h5><p>程序报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</span><br></pre></td></tr></table></figure><h5 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h5><p>.then() 或 .catch() 返回的值不能是 promise 本身，否则会造成死循环。</p><h4 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h4><h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">3</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h5 id="答案-7"><a href="#答案-7" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h5 id="解读-1"><a href="#解读-1" class="headerlink" title="解读"></a>解读</h5><p>先执行整体代码，没有发现微任务；<br>再执行下一个宏任务—setTimeout回调函数，打印出1；<br>遇到微任务—Promise 回调函数；<br>立即执行微任务，打印出3；<br>微任务队列被清空，执行下一个宏任务—下一个setTimeout回调函数，打印出2。</p><h4 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h4><h5 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res, rej</span>) =&gt;</span> &#123;</span><br><span class="line">    res(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">pro.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="答案-8"><a href="#答案-8" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h5 id="解析-7"><a href="#解析-7" class="headerlink" title="解析"></a>解析</h5><p>promise 对象赋值给了变量 pro，每个 .then() 都是独立的。</p><h4 id="题目十一"><a href="#题目十一" class="headerlink" title="题目十一"></a>题目十一</h4><h5 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="答案-9"><a href="#答案-9" class="headerlink" title="答案"></a>答案</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><h5 id="解析-8"><a href="#解析-8" class="headerlink" title="解析"></a>解析</h5><p>注意以下几点:</p><ol><li>定义 async1()，async2()，不会立即执行</li><li>await async2(); 表示先执行 async2()，然后将 await 后面的代码当作 .then() 中的回调来处理</li><li>初始化 promise，promise 中的代码会立即执行</li></ol><p>转自：<a href="https://leetcode-cn.com/circle/discuss/sQXY3u/">https://leetcode-cn.com/circle/discuss/sQXY3u/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack如何提高构建速度</title>
      <link href="2021/08/04/17/"/>
      <url>2021/08/04/17/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack如何提高构建速度"><a href="#webpack如何提高构建速度" class="headerlink" title="webpack如何提高构建速度"></a>webpack如何提高构建速度</h3><ol><li>多入口情况下，使用CommonsChunkPlugin来提取公共代码；</li><li>通过externals配置来提取常用库;</li><li>利用DllPlugin和DllReferencePlugin预编译资源模块通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来;</li><li>使用Happypack 实现多线程加速编译;</li><li>使用webpack-uglify-paralle来提升uglifyPlugin的压缩速度。 原理上webpack-uglify-parallel采用了多核并行压缩来提升压缩速度;</li><li>使用Tree-shaking和Scope Hoisting来剔除多余代码.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree-shaking</title>
      <link href="2021/08/04/18/"/>
      <url>2021/08/04/18/</url>
      
        <content type="html"><![CDATA[<h3 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree-shaking"></a>Tree-shaking</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数柯里化</title>
      <link href="2021/08/04/2/"/>
      <url>2021/08/04/2/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><blockquote><p>接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><span id="more"></span><h3 id="二、add函数示例"><a href="#二、add函数示例" class="headerlink" title="二、add函数示例"></a>二、add函数示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通的add函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    rerturn x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//柯里化后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">//3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure><h3 id="三、优点"><a href="#三、优点" class="headerlink" title="三、优点"></a>三、优点</h3><h4 id="1-参数复用"><a href="#1-参数复用" class="headerlink" title="1. 参数复用"></a>1. 参数复用</h4><p>例：封装正则校验</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//柯里化后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingCheck</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">txt</span>) </span>&#123;</span><br><span class="line">        retunr reg.test(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字校验</span></span><br><span class="line"><span class="keyword">var</span> hasNumber = curryingCheck(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">hasNumber(<span class="string">&#x27;test1&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="2-提前确认"><a href="#2-提前确认" class="headerlink" title="2. 提前确认"></a>2. 提前确认</h4><p>例：封装dom操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原函数</span></span><br><span class="line"><span class="keyword">var</span> on = <span class="function"><span class="keyword">function</span>(<span class="params">isSupport</span>)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postman安装使用</title>
      <link href="2021/08/04/3/"/>
      <url>2021/08/04/3/</url>
      
        <content type="html"><![CDATA[<h3 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h3><h4 id="下载链接：https-www-postman-com-downloads"><a href="#下载链接：https-www-postman-com-downloads" class="headerlink" title="下载链接：https://www.postman.com/downloads/"></a>下载链接：<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></h4><span id="more"></span><h3 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h3><p>![3-1](./_data/3-1. PNG)</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>点击 图中的 Create New 创建自己的 workspaces ，用来存放自己要测试接口</p><p>![3-2](./_data/3-2. PNG)</p><p>点击 Create a request 创建请求</p><p>![3-3](./_data/3-3. PNG)</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单页应用和多页应用的区别</title>
      <link href="2021/08/04/13/"/>
      <url>2021/08/04/13/</url>
      
        <content type="html"><![CDATA[<h3 id="单页应用和多页应用的区别"><a href="#单页应用和多页应用的区别" class="headerlink" title="单页应用和多页应用的区别"></a>单页应用和多页应用的区别</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6：WeakSet，Set，Map，WeakMap</title>
      <link href="2021/08/04/14/"/>
      <url>2021/08/04/14/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6：WeakSet，Set，Map，WeakMap"><a href="#ES6：WeakSet，Set，Map，WeakMap" class="headerlink" title="ES6：WeakSet，Set，Map，WeakMap"></a>ES6：WeakSet，Set，Map，WeakMap</h3><p>Set 是一种叫做集合的数据结构，Map 是一种叫做字典的数据结构。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ol><li>Set是一个集合，里面的值都是唯一的，没有重复的。</li><li>Set中可以是任何数据类型，并且添加数据时会进行严格比较，重复数据无法加入。</li><li>Set 本身是一个构造函数，用来生成 Set 数据结构。</li><li>Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</li><li>Set 对象允许你存储任何类型的值，无论是原始值或者是对象引用。它类似于数组，但是成员的值都是唯一的，没有重复的值。</li></ol><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function">(<span class="params">x</span>) =&gt;</span> s.add(x))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><h5 id="Set-中的特殊值"><a href="#Set-中的特殊值" class="headerlink" title="Set 中的特殊值"></a>Set 中的特殊值</h5><p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p><ol><li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；</li><li>undefined 与 undefined 是恒等的，所以不重复；</li><li>NaN 与 NaN 是不恒等的，但是在 Set 中认为 NaN 与 NaN 相等，所有只能存在一个，不重复。</li></ol><h5 id="Set-的属性"><a href="#Set-的属性" class="headerlink" title="Set 的属性"></a>Set 的属性</h5><p>size：返回集合所包含元素的数量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line">items.size <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h5 id="Set-实例对象的方法"><a href="#Set-实例对象的方法" class="headerlink" title="Set 实例对象的方法"></a>Set 实例对象的方法</h5><ol><li>add(value)：添加某个值，返回 Set 结构本身(可以链式调用)。</li><li>delete(value)：删除某个值，删除成功返回 true，否则返回 false。</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员。</li><li>clear()：清除所有成员，没有返回值。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="number">1</span>).add(<span class="number">2</span>).add(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 注意2被加入了两次</span></span><br><span class="line">s.size <span class="comment">// 2</span></span><br><span class="line">s.has(<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">s.has(<span class="number">3</span>) <span class="comment">// false</span></span><br><span class="line">s.delete(<span class="number">2</span>)</span><br><span class="line">s.has(<span class="number">2</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h5><ol><li>keys()：返回键名的遍历器。</li><li>values()：返回键值的遍历器。</li><li>entries()：返回键值对的遍历器。</li><li>forEach()：使用回调函数遍历每个成员。</li></ol><p>由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以 keys 方法和 values 方法的行为完全一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// red</span></span><br><span class="line"><span class="comment">// green</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;red&quot;, &quot;red&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;green&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="comment">// [&quot;blue&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure><h5 id="Array-和-Set-对比"><a href="#Array-和-Set-对比" class="headerlink" title="Array 和 Set 对比"></a>Array 和 Set 对比</h5><ol><li>Array 的 indexOf 方法比 Set 的 has 方法效率低下</li><li>Set 不含有重复值（可以利用这个特性实现对一个数组的去重）</li><li>Set 通过 delete 方法删除某个值，而 Array 只能通过 splice。两者的使用方便程度前者更优</li><li>Array 的很多新方法 map、filter、some、every 等是 Set 没有的（但是通过两者可以互相转换来使用）</li></ol><h5 id="Set-的应用"><a href="#Set-的应用" class="headerlink" title="Set 的应用"></a>Set 的应用</h5><p>1、Array.from 方法可以将 Set 结构转为数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items)</span><br></pre></td></tr></table></figure><p>2、数组去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array))</span><br></pre></td></tr></table></figure><p>3、数组的map和filter方法也可以间接用于set</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].map(<span class="function">(<span class="params">x</span>) =&gt;</span> x * <span class="number">2</span>))</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">set = <span class="keyword">new</span> <span class="built_in">Set</span>([...set].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> x % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure><p>4、实现并集 (Union)、交集 (Intersect) 和差集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b])</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> b.has(x)))</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 差集</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !b.has(x)))</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([...b].filter(<span class="function">(<span class="params">x</span>) =&gt;</span> !a.has(x)))</span><br><span class="line"><span class="comment">// Set &#123;4&#125;</span></span><br></pre></td></tr></table></figure><h4 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h4><ol><li>弱引用Set。只能存储对象，不能存储其他类型。且只保持对其中对象的弱引用，若外部无对此对象的引用，或者对象被删除，则WeakSet中将不再有此对象。</li><li>因为成员都是弱引用，随时可能消失，遍历不能保证成员的存在。所以 WeakSet 不能遍历。</li><li>WeakSet 结构与 Set 类似，也是不重复的值的集合。</li><li>成员都是数组和类似数组的对象，若调用 add() 方法时传入了非数组和类似数组的对象的参数，就会抛出错误。</li><li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏。</li><li>WeakSet 不可迭代，因此不能被用在 for-of 等循环中。</li><li>WeakSet 没有 size 属性。</li></ol><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map是一个键值对。</p><p>Map与Object的区别是：</p><ol><li>Object的key只能是String和Symbol类型，而Map的key可以是任何基本类型(String, Number, Boolean, undefined, NaN….)或对象类型(Map, Set, Object, Function , Symbol , null….)</li><li>Map有size属性，可以方便的获取Map的长度，但是Object无法直接获取长度</li></ol><p>Map 的属性:</p><ol><li>size: 返回集合所包含元素的数量</li></ol><p>Map 对象的方法:</p><ol><li>set(key, val): 向 Map 中添加新元素</li><li>get(key): 通过键值查找特定的数值并返回</li><li>has(key): 判断 Map 对象中是否有 Key 所对应的值，有返回 true，否则返回 false</li><li>delete(key): 通过键值从 Map 中移除对应的数据</li><li>clear(): 将这个 Map 中的所有元素删除</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">    p: <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">m.set(o, <span class="string">&#x27;content&#x27;</span>)</span><br><span class="line">m.get(o) <span class="comment">// &quot;content&quot;</span></span><br><span class="line">m.has(o) <span class="comment">// true</span></span><br><span class="line">m.delete(o) <span class="comment">// true</span></span><br><span class="line">m.has(o) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h4><p>弱引用Map。WeakMap有如下特点：</p><ol><li>WeakMap的key只能是对象，不能是基本类型，且对象不计入垃圾回收机制</li><li>WeakMap没有keys、values、entries、size方法</li><li>WeakMap没有遍历操作，无法遍历</li></ol><p>WeakMap和WeakSet的作用，可以用来存储DOM节点，保持与DOM节点相关的数据，当DOM节点被删除后，集合中的数据自动删除，<br>这样就不必担心移除DOM节点时的内存泄漏了。</p><p>转发：<a href="https://segmentfault.com/a/1190000022936727">https://segmentfault.com/a/1190000022936727</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>衍生：ESLint的运行原理</title>
      <link href="2021/08/04/15/"/>
      <url>2021/08/04/15/</url>
      
        <content type="html"><![CDATA[<h3 id="衍生：ESLint的运行原理"><a href="#衍生：ESLint的运行原理" class="headerlink" title="衍生：ESLint的运行原理"></a>衍生：ESLint的运行原理</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ESLint 的用法包括两部分： 通过配置文件配置 lint 规则； 通过命令行执行 lint，找出不符合规范的地方</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack构建原理分析</title>
      <link href="2021/08/04/16/"/>
      <url>2021/08/04/16/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack构建原理分析"><a href="#webpack构建原理分析" class="headerlink" title="webpack构建原理分析"></a>webpack构建原理分析</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>entry：一个可执行模块或者库的入口。</li><li>chunk：多个文件组成一个代码块。可以将可执行的模块和他所依赖的模块组合成一个chunk，这是打包。</li><li>loader：文件转换器。例如把es6转为es5，scss转为css等</li><li>plugin：扩展webpack功能的插件。在webpack构建的生命周期节点上加入扩展hook，添加功能。</li></ol><span id="more"></span><h4 id="webpack构建流程（原理）"><a href="#webpack构建流程（原理）" class="headerlink" title="webpack构建流程（原理）"></a>webpack构建流程（原理）</h4><p>从启动构建到输出结果一系列过程：</p><p>1.初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数，形成最后的配置结果。</p><p>2.开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的 run 方法开始执行编译。</p><p>3.确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去。</p><p>（4）编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。</p><p>（5）完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry配置生成代码块chunk。</p><p>（6）输出完成：输出所有的chunk到文件系统。</p><p>注意：在构建生命周期中有一系列插件在做合适的时机做合适事情，比如UglifyPlugin会在loader转换递归完对结果使用UglifyJs压缩覆盖之前的结果。</p><p>转发：<a href="https://www.cnblogs.com/chengxs/p/11022842.html">https://www.cnblogs.com/chengxs/p/11022842.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包 </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 与 vite</title>
      <link href="2021/08/04/11/"/>
      <url>2021/08/04/11/</url>
      
        <content type="html"><![CDATA[<h3 id="vue3-与-vite"><a href="#vue3-与-vite" class="headerlink" title="vue3 与 vite"></a>vue3 与 vite</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> 打包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call、apply、bind、new的手写</title>
      <link href="2021/08/04/1/"/>
      <url>2021/08/04/1/</url>
      
        <content type="html"><![CDATA[<h3 id="一、实现call函数"><a href="#一、实现call函数" class="headerlink" title="一、实现call函数"></a>一、实现call函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.c = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当传入的t为基础类型时，直接挂载fn会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> t !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="built_in">Object</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//t为可选参数，如果不传的话默认上下文为window</span></span><br><span class="line">    t = t || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">//给t创建一个fn属性，并将值设置为需要调用的函数 </span></span><br><span class="line">    t.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">//call可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</span></span><br><span class="line">    <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> result = t.fn(...args)</span><br><span class="line">    <span class="comment">//调用函数并将对象上的函数删除</span></span><br><span class="line">    <span class="keyword">delete</span> t.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="二、实现apply函数"><a href="#二、实现apply函数" class="headerlink" title="二、实现apply函数"></a>二、实现apply函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当传入的t为基础类型时，直接挂载fn会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> t !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="built_in">Object</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//t为可选参数，如果不传的话默认上下文为window</span></span><br><span class="line">    t = t || <span class="built_in">window</span></span><br><span class="line">    <span class="comment">//给t创建一个fn属性，并将值设置为需要调用的函数 </span></span><br><span class="line">    t.fn = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> r</span><br><span class="line">    <span class="comment">//处理参数和call有区别</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">        r = t.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r = t.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> t.fn</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、实现bind函数"><a href="#三、实现bind函数" class="headerlink" title="三、实现bind函数"></a>三、实现bind函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.protype.b = <span class="function"><span class="keyword">function</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> _this = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> args = [...argument].slice(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">            <span class="comment">//对于new的情况，不会被任何方式改变this，所以对于这种情况我们需要忽略传入的this</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> _this(..args, ...arguments)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//直接调用，使用apply，因为bind可以实现柯里化，f.find(obj,1)(2)，所以需要将两边的参数拼接起来</span></span><br><span class="line">            <span class="keyword">return</span> _this.apply(t, args.concat(...arguments))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、实现一个new"><a href="#四、实现一个new" class="headerlink" title="四、实现一个new"></a>四、实现一个new</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//新生成一个对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">//获取构造函数</span></span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">//链接到原型</span></span><br><span class="line">    obj.__proto__ = Con.prototype</span><br><span class="line">    <span class="comment">//绑定this并执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">//确保返回值为对象</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="2021/08/04/10/"/>
      <url>2021/08/04/10/</url>
      
        <content type="html"><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h5><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个; </li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数; </li><li>针对所有的元素重复以上的步骤，除了最后一个; </li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><span id="more"></span><h5 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h5><p><img src="/2021/08/04/10/bubbleSort.gif" alt="bubbleSort"></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[i]) &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法步骤：-1"><a href="#算法步骤：-1" class="headerlink" title="算法步骤："></a>算法步骤：</h5><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置；</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾；</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><h5 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h5><p><img src="/2021/08/04/10/selectionSort.gif" alt="selectionSort"></p><h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                minIndex = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[minIndex];</span><br><span class="line">        arr[minIndex] = a[i];</span><br><span class="line">        a[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列；</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><h5 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h5><p><img src="/2021/08/04/10/insertionSort.gif" alt="insertionSort"></p><h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> preIndex, cur;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        cur = arr[i]</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; cur) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h5 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h5><p><img src="/2021/08/04/10/shellSort.gif" alt="shellSort"></p><h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">let</span> gap = <span class="number">1</span>,</span><br><span class="line">        temp;</span><br><span class="line">    <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">let</span> j = i - gap;</span><br><span class="line">            <span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><h5 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h5><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h5 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h5><p><img src="/2021/08/04/10/mergeSort.gif" alt="mergeSort"></p><h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3 与 vite</title>
      <link href="2021/08/04/12/"/>
      <url>2021/08/04/12/</url>
      
        <content type="html"><![CDATA[<h3 id="yarn-与-npm"><a href="#yarn-与-npm" class="headerlink" title="yarn 与 npm"></a>yarn 与 npm</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和svn</title>
      <link href="2021/08/04/19/"/>
      <url>2021/08/04/19/</url>
      
        <content type="html"><![CDATA[<h3 id="git和svn"><a href="#git和svn" class="headerlink" title="git和svn"></a>git和svn</h3><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol><li>SVN（Subversion）是集中式管理的版本控制器，而Git是分布式管理的版本控制器！这是两者之间最核心的区别。</li><li>SVN只有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</li><li>Git每一个终端都是一个仓库，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。每一次的提取操作，实际上都是一次对代码仓库的完整备份。</li><li>Git不仅仅是个版本控制系统，它也是个内容管理系统（CMS），工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应Git提供的一些概念和特征。</li></ol><span id="more"></span><p><img src="/2021/08/04/19/git.png" alt="git"></p><p><img src="/2021/08/04/19/svn.png" alt="svn"></p><h4 id="集中式版本控制系统："><a href="#集中式版本控制系统：" class="headerlink" title="集中式版本控制系统："></a>集中式版本控制系统：</h4><p>版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p><p><img src="/2021/08/04/19/tsg.png" alt="tsg"></p><p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟。</p><h4 id="分布式版本控制系统："><a href="#分布式版本控制系统：" class="headerlink" title="分布式版本控制系统："></a>分布式版本控制系统：</h4><ol><li>首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</li><li>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</li><li>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</li></ol><p>当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。</p><p>转发：<a href="https://www.cnblogs.com/kevingrace/p/5904595.html">https://www.cnblogs.com/kevingrace/p/5904595.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-dev-server解决跨域</title>
      <link href="2021/08/04/20/"/>
      <url>2021/08/04/20/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack-dev-server解决跨域"><a href="#webpack-dev-server解决跨域" class="headerlink" title="webpack-dev-server解决跨域"></a>webpack-dev-server解决跨域</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打包 </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中mixins的使用方法和注意点</title>
      <link href="2021/08/04/21/"/>
      <url>2021/08/04/21/</url>
      
        <content type="html"><![CDATA[<h3 id="vue中mixins的使用方法和注意点"><a href="#vue中mixins的使用方法和注意点" class="headerlink" title="vue中mixins的使用方法和注意点"></a>vue中mixins的使用方法和注意点</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue混入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 常用指令</title>
      <link href="2021/08/04/22/"/>
      <url>2021/08/04/22/</url>
      
        <content type="html"><![CDATA[<h3 id="git-常用指令"><a href="#git-常用指令" class="headerlink" title="git 常用指令"></a>git 常用指令</h3><h4 id="git-clone-命令"><a href="#git-clone-命令" class="headerlink" title="git clone 命令"></a>git clone 命令</h4><blockquote><p>$ git clone <a href="https://github.com/libgit2/libgit2">https://github.com/libgit2/libgit2</a></p></blockquote><p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。</p><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p><blockquote><p>$ git clone <a href="https://github.com/libgit2/libgit2">https://github.com/libgit2/libgit2</a> mylibgit</p></blockquote><p>这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。</p><span id="more"></span><h4 id="git-status-命令"><a href="#git-status-命令" class="headerlink" title="git status 命令"></a>git status 命令</h4><p>可以用 git status 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p><blockquote><p>$ git status<br>On branch master<br>Your branch is up-to-date with ‘origin/master’.<br>nothing to commit, working directory clean</p></blockquote><p>当前目录下没有出现任何处于未跟踪状态的新文件，若新增或者修改了文件则会出现以下输出：</p><blockquote><p>$ echo ‘My Project’ &gt; README<br>$ git status<br>On branch master<br>Your branch is up-to-date with ‘origin/master’.<br>Untracked files:<br>(use “git add <file>…” to include in what will be committed)</file></p><p>README</p><p>nothing added to commit but untracked files present (use  “git add” to track)</p></blockquote><p>git status 命令的输出十分详细，但其用语有些繁琐。<br>Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。<br>如果你使用 git status -s 命令或 git status –short 命令，你将得到一种格式更为紧凑的输出。</p><blockquote><p>$ git status -s<br>M README<br>MM Rakefile<br>A  lib/git.rb<br>M  lib/simplegit.rb<br>?? LICENSE.txt</p></blockquote><p>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile 文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p><h4 id="git-add-命令"><a href="#git-add-命令" class="headerlink" title="git add 命令"></a>git add 命令</h4><blockquote><p>$ git add README</p></blockquote><p>新文件可通过git add来跟踪， git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 来看一个实际的 .gitignore 例子：</p><blockquote><p>$ cat .gitignore<br>*.[oa]<br>*~</p></blockquote><p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。</p><blockquote><p>//忽略所有的 .a 文件<br><em>.a<br>//但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件<br>!lib.a<br>//只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO<br>/TODO<br>//忽略任何目录下名为 build 的文件夹<br>build/<br>//忽略 doc/notes.txt，但不忽略 doc/server/arch.txt<br>doc/</em>.txt<br>//忽略 doc/ 目录及其所有子目录下的 .pdf 文件<br>doc/**/*.pdf</p></blockquote><h4 id="git-diff-命令"><a href="#git-diff-命令" class="headerlink" title="git diff 命令"></a>git diff 命令</h4><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff：</p><blockquote><p>$ git diff</p></blockquote><p> 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。</p><p> 若要查看已暂存的将要添加到下次提交里的内容，可以用</p><blockquote><p>git diff –staged （ –staged 和 –cached 是同义词）</p></blockquote><p>命令。 这条命令将比对已暂存文件与最后一次提交的文件差异。</p><h4 id="git-commit-命令"><a href="#git-commit-命令" class="headerlink" title="git commit 命令"></a>git commit 命令</h4><p>现在的暂存区已经准备就绪，可以提交了。 在此之前，请务必确认还有什么已修改或新建的文件还没有 git add 过， 否则提交的时候不会记录这些尚未暂存的变化。 这些已修改但未暂存的文件只会保留在本地磁盘。 所以，每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了， 然后再运行提交命令 git commit。在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行。</p><blockquote><p>git commit -m “提交代码”</p></blockquote><p>给 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。</p><blockquote><p>$ git commit -a -m ‘提交代码’</p></blockquote><p>最好还是不要不要跳过git add 步骤，防止提交无用没见，每次提交前都执行下git status 查看文件状态。</p><h4 id="git-rm-命令"><a href="#git-rm-命令" class="headerlink" title="git rm 命令"></a>git rm 命令</h4><p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><blockquote><p>$ git rm PROJECTS.md</p></blockquote><p>下一次提交时，该文件就不再纳入版本管理了。 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 -f（译注：即 force 的首字母）。 这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。 当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 .a 这样的编译生成文件添加到暂存区时，这一做法尤其有用。 为达到这一目的，使用 –cached 选项：</p><blockquote><p>$ git rm –cached README</p></blockquote><p>git rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。比如：</p><blockquote><p>$ git rm log/*.log</p></blockquote><p>注意到星号 * 之前的反斜杠 \， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开。 此命令删除 log/ 目录下扩展名为 .log 的所有文件。 类似的比如：</p><blockquote><p>$ git rm *~</p></blockquote><p>该命令会删除所有名字以 ~ 结尾的文件。</p><h4 id="git-mv-命令"><a href="#git-mv-命令" class="headerlink" title="git mv 命令"></a>git mv 命令</h4><p> 要在 Git 中对文件改名，可以这么做：</p><blockquote><p>$ git mv file_from file_to</p></blockquote><p> 其实，运行 git mv 就相当于运行了下面三条命令：</p><blockquote><p>$ mv README.md README<br>$ git rm README.md<br>$ git add README</p></blockquote><h4 id="git-log-命令"><a href="#git-log-命令" class="headerlink" title="git log 命令"></a>git log 命令</h4><blockquote><p>git log</p></blockquote><p>不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p><blockquote><p>$ git log -p -2</p></blockquote><p>-p 或 –patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 -2 选项来只显示最近的两次提交。</p><p>该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，这个参数就非常有用了。</p><blockquote><p>$ git log –stat</p></blockquote><p>如果想看到每次提交的简略统计信息，可以使用 –stat 选项。</p><p>参考：<a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93">https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git的传输协议</title>
      <link href="2021/08/04/24/"/>
      <url>2021/08/04/24/</url>
      
        <content type="html"><![CDATA[<h3 id="git的传输协议"><a href="#git的传输协议" class="headerlink" title="git的传输协议"></a>git的传输协议</h3><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4><p>Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。</p><p>值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。</p><span id="more"></span><h4 id="本地协议"><a href="#本地协议" class="headerlink" title="本地协议"></a>本地协议</h4><p>最基本的就是_本地协议（Local protocol）_，所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录。这常见于团队每一个成员都对一个共享的文件系统（例如 NFS）拥有访问权，或者比较少见的多人共用同一台电脑的情况。后面一种情况并不安全，因为所有代码仓库实例都储存在同一台电脑里，增加了灾难性数据损失 的可能性。</p><p>如果你使用一个共享的文件系统，就可以在一个本地文件系统中克隆仓库，推送和获取。克隆的时候只需要将远程仓库的路径作为 URL 使用，比如下面这样：</p><blockquote><p>$ git clone /opt/git/project.git</p></blockquote><p>或者这样：</p><blockquote><p>$ git clone file:///opt/git/project.git</p></blockquote><p>如果在 URL 开头明确使用 file:// ，那么 Git 会以一种略微不同的方式运行。如果你只给出路径，Git 会尝试使用硬链接或直接复制它所需要的文件。如果使用了file:// ，Git 会调用它平时通过网络来传输数据的工序，而这种方式的效率相对较低。使用 file:// 前缀的主要原因是当你需要一个不包含无关引用或对象的干净仓库副本的时候 — 一般指从其他版本控制系统导入的，或类似情形（参见第 9 章的维护任务）。我们这里仅仅使用普通路径，这样更快。</p><p>要添加一个本地仓库作为现有 Git 项目的远程仓库，可以这样做：</p><blockquote><p>$ git remote add local_proj /opt/git/project.git</p></blockquote><p>然后就可以像在网络上一样向这个远程仓库推送和获取数据了。</p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>基于文件仓库的优点在于它的简单，同时保留了现存文件的权限和网络访问权限。如果你的团队已经有一个全体共享的文件系统，建立仓库就十分容易了。你 只需把一份裸仓库的副本放在大家都能访问的地方，然后像对其他共享目录一样设置读写权限就可以了。我们将在下一节“在服务器上部署 Git ”中讨论如何导出一个裸仓库的副本。</p><p>这也是从别人工作目录中获取工作成果的快捷方法。假如你和你的同事在一个项目中合作，他们想让你检出一些东西的时候，运行类似 git pull /home/john/project 通常会比他们推送到服务器，而你再从服务器获取简单得多。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>这种方法的缺点是，与基本的网络连接访问相比，难以控制从不同位置来的访问权限。如果你想从家里的笔记本电脑上推送，就要先挂载远程硬盘，这和基于网络连接的访问相比更加困难和缓慢。</p><p>另一个很重要的问题是该方法不一定就是最快的，尤其是对于共享挂载的文件系统。本地仓库只有在你对数据访问速度快的时候才快。在同一个服务器上，如果二者同时允许 Git 访问本地硬盘，通过 NFS 访问仓库通常会比 SSH 慢。</p><h4 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h4><p>Git 使用的传输协议中最常见的可能就是 SSH 了。这是因为大多数环境已经支持通过 SSH 对服务器的访问 — 即便还没有，架设起来也很容易。SSH 也是唯一一个同时支持读写操作的网络协议。另外两个网络协议（HTTP 和 Git）通常都是只读的，所以虽然二者对大多数人都可用，但执行写操作时还是需要 SSH。SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。</p><p>通过 SSH 克隆一个 Git 仓库，你可以像下面这样给出 ssh:// 的 URL：</p><blockquote><p>$ git clone ssh://user@server:project.git</p></blockquote><p>或者不指明某个协议 — 这时 Git 会默认使用 SSH ：</p><blockquote><p>$ git clone user@server:project.git</p></blockquote><p>如果不指明用户，Git 会默认使用当前登录的用户名连接服务器。</p><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>使用 SSH 的好处有很多。首先，如果你想拥有对网络仓库的写权限，基本上不可能不使用 SSH。其次，SSH 架设相对比较简单 — SSH 守护进程很常见，很多网络管理员都有一些使用经验，而且很多操作系统都自带了它或者相关的管理工具。再次，通过 SSH 进行访问是安全的 — 所有数据传输都是加密和授权的。最后，和 Git 及本地协议一样，SSH 也很高效，会在传输之前尽可能压缩数据。</p><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>SSH 的限制在于你不能通过它实现仓库的匿名访问。即使仅为读取数据，人们也必须在能通过 SSH 访问主机的前提下才能访问仓库，这使得 SSH 不利于开源的项目。如果你仅仅在公司网络里使用，SSH 可能是你唯一需要使用的协议。如果想允许对项目的匿名只读访问，那么除了为自己推送而架设 SSH 协议之外，还需要支持其他协议以便他人访问读取。</p><h4 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h4><p>接下来是 Git 协议。这是一个包含在 Git 软件包中的特殊守护进程； 它会监听一个提供类似于 SSH 服务的特定端口（9418），而无需任何授权。打算支持 Git 协议的仓库，需要先创建git-export-daemon-ok 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。要么所有人都能克隆 Git 仓库，要么谁也不能。这也意味着该协议通常不能用来进行推送。你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目 URL 的人将都有推送权限。不用说，这是十分罕见的情况。</p><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>Git 协议是现存最快的传输协议。如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个 Git 守护进程来供应仓库是个不错的选择。它使用与 SSH 协议相同的数据传输机制，但省去了加密和授权的开销。</p><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 接口，让几个开发者拥有推送（写）权限，其他人通过git:// 拥有只读权限。Git 协议可能也是最难架设的协议。它要求有单独的守护进程，需要定制 — 我们将在本章的 “Gitosis” 一节详细介绍它的架设 — 需要设定xinetd 或类似的程序，而这些工作就没那么轻松了。该协议还要求防火墙开放 9418 端口，而企业级防火墙一般不允许对这个非标准端口的访问。大型企业级防火墙通常会封锁这个少见的端口。</p><h4 id="HTTP-S-协议"><a href="#HTTP-S-协议" class="headerlink" title="HTTP/S 协议"></a>HTTP/S 协议</h4><p>最后还有 HTTP 协议。HTTP 或 HTTPS 协议的优美之处在于架设的简便性。基本上，只需要把 Git 的裸仓库文件放在 HTTP 的根目录下，配置一个特定的post-update 挂钩（hook）就可以搞定（Git 挂钩的细节见第 7 章）。此后，每个能访问 Git 仓库所在服务器上 web 服务的人都可以进行克隆操作。下面的操作可以允许通过 HTTP 对仓库进行读取：</p><blockquote><p>$ cd /var/www/htdocs/</p></blockquote><blockquote><p>$ git clone –bare /path/to/git_project gitproject.git</p></blockquote><blockquote><p>$ cd gitproject.git</p></blockquote><blockquote><p>$ mv hooks/post-update.sample hooks/post-update</p></blockquote><blockquote><p>$ chmod a+x hooks/post-update</p></blockquote><p>这样就可以了。Git 附带的 post-update 挂钩会默认运行合适的命令（git update-server-info）来确保通过 HTTP 的获取和克隆正常工作。这条命令在你用 SSH 向仓库推送内容时运行；之后，其他人就可以用下面的命令来克隆仓库：</p><blockquote><p>$ git clone <a href="http://example.com/gitproject.git">http://example.com/gitproject.git</a></p></blockquote><p>在本例中，我们使用了 Apache 设定中常用的 /var/www/htdocs 路径，不过你可以使用任何静态 web 服务 — 把裸仓库放在它的目录里就行。 Git 的数据是以最基本的静态文件的形式提供的（关于如何提供文件的详情见第 9 章）。</p><p>通过 HTTP 进行推送操作也是可能的，不过这种做法不太常见，并且牵扯到复杂的 WebDAV 设定。由于很少用到，本书将略过对该内容的讨论。如果对 HTTP 推送协议感兴趣，不妨打开这个地址看一下操作方法：<a href="http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt">http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt</a> 。通过 HTTP 推送的好处之一是你可以使用任何 WebDAV 服务器，不需要为 Git 设定特殊环境；所以如果主机提供商支持通过 WebDAV 更新网站内容，你也可以使用这项功能。</p><h5 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h5><p>使用 HTTP 协议的好处是易于架设。几条必要的命令就可以让全世界读取到仓库的内容。花费不过几分钟。HTTP 协议不会占用过多服务器资源。因为它一般只用到静态的 HTTP 服务提供所有数据，普通的 Apache 服务器平均每秒能支撑数千个文件的并发访问 — 哪怕让一个小型服务器超载都很难。</p><p>你也可以通过 HTTPS 提供只读的仓库，这意味着你可以加密传输内容；你甚至可以要求客户端使用特定签名的 SSL 证书。一般情况下，如果到了这一步，使用 SSH 公共密钥可能是更简单的方案；不过也存在一些特殊情况，这时通过 HTTPS 使用带签名的 SSL 证书或者其他基于 HTTP 的只读连接授权方式是更好的解决方案。</p><p>HTTP 还有个额外的好处：HTTP 是一个如此常见的协议，以至于企业级防火墙通常都允许其端口的通信。</p><h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>HTTP 协议的消极面在于，相对来说客户端效率更低。克隆或者下载仓库内容可能会花费更多时间，而且 HTTP 传输的体积和网络开销比其他任何一个协议都大。因为它没有按需供应的能力 — 传输过程中没有服务端的动态计算 — 因而 HTTP 协议经常会被称为_傻瓜（dumb）_协议。更多 HTTP 协议和其他协议效率</p><p>转发：<a href="https://blog.csdn.net/return_cc/article/details/78419533">https://blog.csdn.net/return_cc/article/details/78419533</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svn 常用指令</title>
      <link href="2021/08/04/23/"/>
      <url>2021/08/04/23/</url>
      
        <content type="html"><![CDATA[<h3 id="svn-常用指令"><a href="#svn-常用指令" class="headerlink" title="svn 常用指令"></a>svn 常用指令</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用git分支管理hexo博客源码</title>
      <link href="2021/08/04/25/"/>
      <url>2021/08/04/25/</url>
      
        <content type="html"><![CDATA[<h3 id="使用git分支管理hexo博客源码"><a href="#使用git分支管理hexo博客源码" class="headerlink" title="使用git分支管理hexo博客源码"></a>使用git分支管理hexo博客源码</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>使用hexo写博客的流程通常是：</p><ol><li>通过hexo new post_name命令，会自动在source/_post目录下生成一个待写的post_name.md文件；</li><li>编写完该md文件后，用hexo generate编译生成对应的HTML文件；</li><li>发布之前，可以用hexo s本地预览，然后通过hexo deploy发布到远程仓库的master分支，然后你的个人站点就能看到刚才新加的文章了。</li></ol><p>然而，远程仓库只会保存hexo发布后的静态HTML文件，博客md源文件、主题配置等还在本地，一旦电脑磁盘坏了或者换了电脑，就无法在之前仓库的基础上继续写博客。</p><span id="more"></span><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="新建git分支"><a href="#新建git分支" class="headerlink" title="新建git分支"></a>新建git分支</h5><p>Github Page要求使用master分支作为发布网站的源代码，我们只能用master分支来保存hexo生成的静态网页，所以可以新建一个dev分支来保存源代码。</p><p>如图在红框位置输入需要新建的分支名就会提示新建分支，此处我已经新建，故直接显示dev分支。</p><p><img src="/2021/08/04/25/25-1.png" alt="&#39;新建分支&#39;"></p><p>此时建立的分支是从master分支克隆过来的，因而master中已有的public等deploy生成的文件也会一起带过来，这些都不算是博客源文件。可以先在本地把它删掉，然后提交推送到GitHub上的dev分支</p><blockquote><p>git add .<br>git commit -m ‘删除public文件’<br>git push origin dev</p></blockquote><h5 id="更改仓库的默认分支"><a href="#更改仓库的默认分支" class="headerlink" title="更改仓库的默认分支"></a>更改仓库的默认分支</h5><p>github上的仓库初始都会有个master分支，也就是默认分支。<br>对于一个仓库project_name，当我们通过</p><blockquote><p>git clone <a href="https://github.com/sherlockyb/project_name.git">https://github.com/sherlockyb/project_name.git</a></p></blockquote><p>下载代码时，实际拉取的是默认分支master对应的代码。<br>而我们用hexo写博客时，通常是与md源文件打交道，对于deploy生成的master分支代码并不需要我们关注，因此可将仓库的默认分支改为保存源码的dev分支，这样通过git clone拉取的就是dev分支代码了。</p><p>在仓库的主页面，通过Settings -&gt; Branchs，可以看到Default branch的Tab，显示的默认分支是master，可以勾选dev，然后update即可将默认分支设置为dev，如下图：</p><p><img src="/2021/08/04/25/25-2.png" alt="&#39;更改仓库的默认分支&#39;"></p><h5 id="推送博客源码"><a href="#推送博客源码" class="headerlink" title="推送博客源码"></a>推送博客源码</h5><p>将本地的md源文件、站点配置文件等推送到source分支。</p><p>因为我们只需要保留博客源码，其他无关的文件并不希望推送，需要确保配好了.gitignore文件，通常如下：</p><blockquote><p>.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</p></blockquote><p>然后执行:</p><blockquote><p>git add .<br>git commit -m ‘新增博客’<br>git push origin dev</p></blockquote><p>将源代码修改已经新增的博客md上传到dev分支</p><h5 id="新环境"><a href="#新环境" class="headerlink" title="新环境"></a>新环境</h5><p>假设我们换电脑了，要在新环境继续在原有仓库基础上撸文章，此时通过git clone将博客源码拉到本地，然后安装、初始化hexo就能搞定。</p><p>转发：<a href="https://blog.csdn.net/weixin_29164081/article/details/112712581">https://blog.csdn.net/weixin_29164081/article/details/112712581</a></p><p>git push –set-upstream origin dev<br>git pull –rebase origin dev<br>git remote set-url origin <a href="https://github.com/xdw-h/xdw-h.github.io.git">https://github.com/xdw-h/xdw-h.github.io.git</a><br>git remote add origin <a href="https://github.com/xdw-h/xdw-h.github.io.git">https://github.com/xdw-h/xdw-h.github.io.git</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>reflow(回流)和repaint(重绘)</title>
      <link href="2021/08/04/26/"/>
      <url>2021/08/04/26/</url>
      
        <content type="html"><![CDATA[<h3 id="reflow-回流-和repaint-重绘"><a href="#reflow-回流-和repaint-重绘" class="headerlink" title="reflow(回流)和repaint(重绘)"></a>reflow(回流)和repaint(重绘)</h3><h4 id="render-tree"><a href="#render-tree" class="headerlink" title="render tree"></a>render tree</h4><p>DOM Tree 和样式结构体组合后构建render tree</p><h4 id="回流-reflow"><a href="#回流-reflow" class="headerlink" title="回流(reflow)"></a>回流(reflow)</h4><ol><li>当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)；</li><li>每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。</li></ol><span id="more"></span><h4 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(repaint)</h4><ol><li>在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为重绘；</li><li>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘()。</li></ol><h4 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h4><ol><li>回流必将引起重绘，而重绘不一定会引起回流；</li><li>当页面布局和几何属性改变时就需要回流，比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变；</li><li>回流的花销跟render tree有多少节点需要重新构建有关系；</li><li>浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush（清空）队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</li></ol><h4 id="cssText的使用场景"><a href="#cssText的使用场景" class="headerlink" title="cssText的使用场景"></a>cssText的使用场景</h4><p>有时我们需要使用原生js写css样式，比如</p><blockquote><p>obj.style.width = ‘100px’;<br>obj.style.height = ‘100px’; </p></blockquote><p>这种写法1, 2个样式还好，当出现多个样式时，这种写法就会显得比较繁琐，并且js覆写样式是会销毁原样式并重建的过程，这种销毁和重建，都会增加浏览器的开销。</p><ol><li>这时我们可以使用cssText属性进行累加:</li></ol><blockquote><p>ele.style.cssText += ‘width: 100px; height: 100px; color: #000; font-size: 14px; background: #ccc’; </p></blockquote><p>但是，cssText（假如不为空）在IE中最后一个分号会被删掉， 可以在前面添加一个分号来解决这个问题</p><blockquote><p>ele.style.cssText += ‘; width: 100px; height: 100px; color: #000; font-size: 14px; background: #ccc’; </p></blockquote><ol start="2"><li>可以先把dom的display置为none，等所有样式修改完，再置为block，虽然也会引起回流，但减少了回流次数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见单位：px、em、rem、vw、vh及之前区别，使用</title>
      <link href="2021/08/04/27/"/>
      <url>2021/08/04/27/</url>
      
        <content type="html"><![CDATA[<h3 id="常见单位：px、em、rem、vw、vh及之前区别，使用"><a href="#常见单位：px、em、rem、vw、vh及之前区别，使用" class="headerlink" title="常见单位：px、em、rem、vw、vh及之前区别，使用"></a>常见单位：px、em、rem、vw、vh及之前区别，使用</h3><h4 id="px"><a href="#px" class="headerlink" title="px"></a>px</h4><p>px：绝对单位，页面按精确像素展示</p><h4 id="em"><a href="#em" class="headerlink" title="em"></a>em</h4><p>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值。</p><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>body</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>div1</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>div2</span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div3&quot;</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>计算关系是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>body的font-size是继承自跟元素html，html的尺寸是浏览器默认尺寸14px；<br>div1的font-size=1.5<em>14px = 21px;<br>div2的font-size=1.5</em>21px = 31.5px;<br>div3的font-size=1.5*31.5px = 47.25px; </p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持。<br>(另外需注意chrome强制最小字体为12号，即使设置成 10px 最终都会显示成 12px，当把html的font-size设置成10px, 子节点rem的计算还是以12px为基准)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.div3</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时div3的font-size = 1.5<em>14px = 1.5</em>html的font-size</p><p>在所有现代浏览器中，其默认的字体大小就是“16px”。因此在浏览器下默认的设置将是：<br>1em = 16px</p><hr><p>使用vw，vh时，需设置meta缩放比1:1</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="vw"><a href="#vw" class="headerlink" title="vw"></a>vw</h4><p>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</p><h4 id="vh"><a href="#vh" class="headerlink" title="vh"></a>vh</h4><p>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</p><h4 id="vmin"><a href="#vmin" class="headerlink" title="vmin"></a>vmin</h4><p>vmin：vw和vh中较小的那个。</p><h4 id="vmax"><a href="#vmax" class="headerlink" title="vmax"></a>vmax</h4><p>vmax：vw和vh中较大的那个。</p><ol><li>相对于视口的高度和宽度，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。</li><li>比如：浏览器高度900px，宽度为750px, 1 vh = 900px/100 = 9 px，1vw = 750px/100 = 7.5 px。</li><li>很容易实现与同屏幕等高的框：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.slide</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>设置一个和屏幕同宽的标题，</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100vw</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那标题的字体大小就会自动根据浏览器的宽度进行缩放，以达到字体和viewport大小同步的效果。<br>5. vmin and vmax：关于视口高度和宽度两者的最小值或者最大值。<br>6. 浏览器的宽度设置为1200px，高度设置为800px， 1vmax = 1200/100px = 12px， 1vmin = 800/100px = 8px。如果宽度设置为600px, 高度设置为1080px, 1vmin就等于6px, 1vmax则未10.8px。<br>7. 有一个元素，你需要让它始终在屏幕上可见：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vmin</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vmin</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>如果你要让这个元素始终铺满整个视口的可见区域：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vmax</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100vmax</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC相关概念</title>
      <link href="2021/08/04/28/"/>
      <url>2021/08/04/28/</url>
      
        <content type="html"><![CDATA[<h3 id="BFC相关概念"><a href="#BFC相关概念" class="headerlink" title="BFC相关概念"></a>BFC相关概念</h3><p>一个块格式化上下文（block formatting context）是Web页面的可视化CSS渲染的一部分。用于决定块盒子的布局及浮动相互影响范围的一个区域。</p><span id="more"></span><ul><li>触发BFC<ul><li>body 根元素</li><li>浮动元素：float除none以外的值</li><li>绝对定位元素：position(absolute、fixed）</li><li>display为inline-block、table-cells、flex</li><li>overflow除了visible以外的值(hidden、auto、scroll)</li></ul></li><li>特点<ul><li>内部块级盒子垂直方向排列</li><li>盒子垂直距离由margin决定，同一个BFC盒子的外边距会-重叠</li><li>BFC就是一个隔离的容器，内部子元素不会影响到外部元素</li><li>BFC 的区域不会与float box叠加</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>元素A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>元素B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/04/28/28-1.png" alt="&#39;28-1&#39;"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
